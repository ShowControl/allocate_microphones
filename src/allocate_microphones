#!/usr/bin/python3
# -*- coding: utf-8
#
# allocate_microphones is a program to allocate microphones
# between actors in a live stage play.

#   Copyright © 2019 by John Sauter
#                      <John_Sauter@systemeyescomputerstore.com>

#   This program is free software: you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation, either version 3
#   of the License, or (at your option) any later version.

#   This program is distributed in the hope that it will be
#   useful, but WITHOUT ANY WARRANTY; without even the implied
#   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#   See the GNU General Public License for more details.

#   You should have received a copy of the GNU General Public
#   License along with this program.  If you did not,
#   see <http://www.gnu.org/licenses/>.

#   The author's contact information is as follows:
#     John Sauter
#     System Eyes Computer Store
#     20A Northwest Blvd.  Ste 345
#     Nashua, NH  03063-4066
#     telephone: (603) 424-1188
#     e-mail: John_Sauter@systemeyescomputerstore.com

import sys
import re
import pprint
import argparse
import os.path

parser = argparse.ArgumentParser (
  formatter_class=argparse.RawDescriptionHelpFormatter,
  description='Allocate microphones between actors for a live ' +
  'stage play.',
  epilog='Copyright © 2019 by John Sauter' + '\n' +
    'License GPL3+: GNU GPL version 3 or later; ' + '\n' +
    'see <http://gnu.org/licenses/gpl.html> for the full text' +
    ' of the license.' + '\n' +
    'This is free software: you are free to change' +
    ' and redistribute it. ' + '\n' +
    'There is NO WARRANTY, to the extent permitted by law. ' +
    '\n' + '\n'
    'The input file describes the play. ' + '\n'
    'The output is several tables, each in its own file, ' +
    '\n' + 
    'which describe how the ' +
    'microphones are shared between actors.')
parser.add_argument ('input_file',
                     help='the description of the play')
parser.add_argument ('--version', action='version', 
                     version='allocate_microphones 3.3 2019-06-02',
                     help='print the version number and exit')
parser.add_argument ('--trace', metavar='trace_file',
                     help='write trace output to the specified file')
parser.add_argument ('--output_root', metavar='output_root',
                     help='root name for output files')
parser.add_argument ('--output-directory', metavar='output_directory',
                     help='directory for writing output files')
parser.add_argument ('--verbose', type=int, metavar='verbosity level',
                     help='control the amount of output from the program: ' +
                     '1 is normal, 0 suppresses summary messages')

do_trace = 0
tracefile = ""
output_root = ""
output_directory = ""
verbosity_level = 1

microphone_switch_time = 35
min_microphone_off_time = 0
extra_microphones = 0
error_counter = 0

# Actors is a list of dictionaries.  Actors are
# listed in the order encountered.
actors = []

# Characters is a dictionary of dictionaries,
# keyed by the character's name.
characters = {}

# Rolls is a dictionary keyed by actor names,
# in which the corresponding values are a list
# of references to character dictionaries.
rolls = {}

# groups is the dictionary of group names, indexed by name.
# The empty string is the default group and so is always
# present.  Each entry is a dictionary containing the group number
# and name.  Optionally, it can contain preferred_DCA.
# More information will be added later.

groups = dict()
group_number = 1
group_dict = dict()
group_dict["number"] = group_number
group_dict["name"] = ""
group_number = group_number + 1
groups[""] = group_dict

current_code = ""

# Processing routines for each code.
#

# The name of the stage play
show_name = ""
def show_start(value):
  global show_name
  show_name = value
  return

venue_name = ""
designer_name = ""
def show_keyword_value (keyword, value):
  global error_counter
  global venue_name
  global designer_name
  if (keyword == "venue"):
    venue_name = value
    return

  if (keyword == "designer"):
    designer_name = value
    return
  
  print ("Unknown show clause: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return
 
def show_end():
  return

# The maximum number of microphones available
microphone_limit = 0
def microphones_start(value):
  global microphone_limit
  global error_counter
  try:
    microphone_limit = int(value)
  except ValueError:
    print ("Number of microphones must be an integer, not " + value)
    error_counter = error_counter + 1
  return

def microphones_end():
  return

# The number of Digitally-controlled amplifiers (DCAs)
DCA_count_specified = 0
DCA_count = 8
def DCA_start(value):
  global DCA_count_specified
  global DCA_count
  global error_counter
  try:
    DCA_count = int(value)
  except ValueError:
    print ("Number of DCAs must be an integer, not " + value + ".")
    error_counter = error_counter + 1
    return
  DCA_count_specified = 1

DCA_style = "solo"
def DCA_keyword_value (keyword, value):
  global error_counter
  global DCA_style
  if (keyword == "style"):
    if (value == "nosolo" or value == "solo"):
      DCA_style = value
    else:
      print ("Unknown DCA style clause; must be solo or nosolo, not " +
             value + ".")
      error_counter = error_counter + 1
    return
  print ("Unknown DCA clause: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return
  
def DCA_end():
  return

# A character in the play
current_character = ""
def character_start (value):
  global current_character
  global error_counter
  if (value in characters):
    print ("Character " + value + " already defined.")
    error_counter = error_counter + 1
    return
  if (value in groups):
    print ("Group " + value + " is already defined; " +
           "character names must be different from group names.")
    error_counter = error_counter + 1
    return
  characters [value] = {}
  the_character = characters [value]
  the_character ["name"] = value
  the_character ["group"] = ""
  current_character = the_character
  return

def character_keyword_value (keyword, value):
  global current_character
  global error_counter
  global groups
  global group_number
  if (keyword == "group"):
    if (value in characters):
      print ("Character " + value + " already defined; " +
             "group names must be different from character names.")
      error_counter = error_counter + 1
      return
    group_name = value
    # In solo style, group "" means the solo group.  In nosolo style,
    # group "" means the group with the same name as the character.
    if ((DCA_style == "nosolo") and (group_name == "")):
      group_name = current_character["name"]
    current_character ["group"] = group_name
    if (group_name not in groups):
      group_dict = dict()
      group_dict["number"] = group_number
      group_dict["name"] = group_name
      group_number = group_number + 1
      groups[group_name] = group_dict
    return
  if (keyword == "preferred_DCA"):
    if (do_trace == 1):
      tracefile.write ("Preferred DCA of " + str(int(value)) +
                       " for character " +
                       current_character["name"] + ".\n")
    try:
      DCA_number = int(value)
    except ValueError:
      print ("DCA number must be an integer, not " + value)
      error_counter = error_counter + 1
      return
    if (do_trace == 1):
      tracefile.write ("Assigning " + str(DCA_number) + ".\n")
    current_character ["preferred_DCA"] = DCA_number
    return
  print ("Unknown character clause: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return

def character_end ():
  current_character = ""
  return

current_group = ""
def group_start (value):
  global current_group
  global error_counter
  global groups
  global group_number
  if (value in characters):
    print ("Character " + value + " already defined; " +
           "group names must be different from character names.")
    error_counter = error_counter + 1
    return
  if (value not in groups):
    group_dict = dict()
    group_dict["number"] = group_number
    group_dict["name"] = value
    group_number = group_number + 1
    groups[value] = group_dict
  current_group = value
  return

def group_keyword_value (keyword, value):
  global current_group
  global error_counter
  global groups
  if (keyword == "preferred_DCA"):
    try:
      DCA_number = int(value)
    except ValueError:
      print ("DCA number must be an integer, not " + value)
      error_counter = error_counter + 1
      return
    group_dict = groups[current_group]
    group_dict ["preferred_DCA"] = DCA_number
    return
  print ("Unknown group clause: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return

def group_end():
  current_group = ""
  return

# An actor in the performance
current_actor = ""
def actor_start (value):
  global current_actor
  if (value in actors):
    print ("Actor " + value + " already defined.")
    error_counter = error_counter + 1
    return
  the_actor = {}
  the_actor ["name"] = value
  the_actor ["old_microphone"] = 0
  the_actor ["reenters"] = False
  the_actor ["reenters_before_intermission"] = False
  actors.append(the_actor)
  current_actor = the_actor
  return

def actor_keyword_value (keyword, value):
  global current_actor
  global error_counter
  if (keyword == "microphone"):
# Specify the preferred microphone for this actor
    try:
      current_actor ["old_microphone"] = int(value)
    except ValueError:
      print ("Preferred microphone for an actor must be an integer," +
             "not " + value)
      error_counter = error_counter + 1
    current_actor ["reenters"] = True
    current_actor ["reenters_before_intermission"] = True
    return
  print ("Unknown actor clause: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return

def actor_end ():
  return

# Specify which characters are performed by an actor
role_actor = ""
def role_start(value):
  global role_actor
  role_actor = ""
  return

def role_keyword_value (keyword, value):
  global role_actor
  global actors
  global error_counter
  if (keyword == "actor"):
    role_actor = value
    actor_missing = 1
    for the_actor in actors:
      if (the_actor ["name"] == value):
        actor_missing = 0
        break
    if (actor_missing == 1):
      print ("Actor " + name + " not listed.")
      the_actor = {}
      the_actor ["name"] = value
      the_actor ["old_microphone"] = 0
      the_actor ["reenters"] = False
      the_actor ["reenters_before_intermission"] = False
      actors.append(the_actor)
    return
  if (keyword == "character"):
    if (role_actor not in rolls):
      rolls [role_actor] = [] 
    the_roll = rolls [role_actor]
    if (value not in characters):
      print ("Character " + value + " not listed.")
      characters [value] = {}
      the_character = characters [value]
      the_character ["name"] = value
      the_character ["group"] = ""
      error_counter = error_counter + 1
    the_roll.append(characters[value])
    return
  print ("Unknown roll clause: " + keyword + "=" + value)
  error_counter = error_counter + 1

def role_end():
  return

# Find the actor who plays a named character
# if none is assigned, make one up.
#
created_actor = 0
def find_actor (character_name):
  global created_actor
  global actors
  for actor_name in rolls.keys():
    for the_character in rolls [actor_name]:
      if (the_character ["name"] == character_name):
        for the_actor in actors:
          if (the_actor ["name"] == actor_name):
            return the_actor
  created_actor = created_actor + 1
  actor_name = "Uncast #" + str(created_actor)
  print ("Character " + character_name + " has no actor.")
  rolls [actor_name] = []
  the_actor = {}
  the_actor ["name"] = actor_name
  the_actor ["old_microphone"] = 0
  the_actor ["reenters"] = False
  the_actor ["reenters_before_intermission"] = False
  actors.append(the_actor)
  if (character_name not in characters):
    characters [character_name] = {}
    the_character = characters [character_name]
    the_character ["name"] = character_name
    error_counter = error_counter + 1
  the_roll = rolls [actor_name]
  the_roll.append(characters[character_name])
  if (do_trace == 1):
    tracefile.write ("Actor " + actor_name + " created for " +
                     character_name + "\n")
  return the_actor

# Convert a text string of the form <number>, <number><suffix>,
# <number><separator><number>, <number><separator><number><separator><number>
# or <number><suffix><separator><number> into a sortable string.  Do this by
# extending the numbers to four digits, and providing dashes, blanks and zeros
# to convert to <number>-<string>-<number>.
# Simple <number> is used when there is only one action on a page.
# Add a suffix for page numbers in ordinary plays, to mark
# positions on a page.  Use two or three numbers in plays that consist of
# all music, to mark positions by page number and
# measure number, or by page number, song number and measure number.
# Plays with both text and music can add -<measure number> to
# <page><position>.
def make_pageno (value):
  global error_counter
  if (do_trace == 1):
    tracefile.write ("Turning page " + value + " into" +
                     " internal form.\n")
  match_digits = re.match (
    "^(?P<digits>[0-9]+)(?P<suffix>.*)$", value)
  if (match_digits):
    if (do_trace == 1):
      tracefile.write ("Has leading digits.\n")
    the_digits = match_digits.groupdict() ["digits"]
    suffix = match_digits.groupdict() ["suffix"]
    if (len(the_digits) < 1):
      print ("Page numbers must at least start with a number: " +
             value)
      error_counter = error_counter + 1
    while (len(the_digits) < 4):
      the_digits = "0" + the_digits
    trailing_digits = re.match (
      "^(?P<sep>.+?)(?P<trail>[0-9]+)$", suffix)
    if (trailing_digits):
      if (do_trace == 1):
        tracefile.write ("Has trailing digits:\n")
        pprint.pprint (trailing_digits, tracefile)
      trail_digits = trailing_digits.groupdict() ["trail"]
      if (do_trace == 1):
        tracefile.write ("Trailing digits are: " + trail_digits + "\n")
      sep = trailing_digits.groupdict() ["sep"]
      while (len(trail_digits) < 4):
        trail_digits = "0" + trail_digits
      if (do_trace == 1):
        tracefile.write ("Middle section is " + sep + ".\n")
      middle_digits = re.match (
        "^(?P<sep1>[^0-9]+)(?P<mid>[0-9]+)(?P<sep2>[^[0-9]+)$", sep)
      if (do_trace == 1):
        pprint.pprint (middle_digits, tracefile)
      if (middle_digits):
        if (do_trace == 1):
          tracefile.write ("Has middle digits.\n")
        mid_digits = middle_digits.groupdict() ["mid"]
        sep1 = middle_digits.groupdict() ["sep1"]
        sep2 = middle_digits.groupdict() ["sep2"]
        while (len(mid_digits) < 4):
          mid_digits = "0" + mid_digits
        if (do_trace == 1):
          tracefile.write (
            "Return 4: " + the_digits + sep1 + mid_digits + sep2 +
            trail_digits + "\n")
        return the_digits + sep1 + mid_digits + sep2 + trail_digits
      else:
        if (do_trace == 1):
          tracefile.write ("Middle section does not have digits.\n")
        middle_text = re.match (
          "^(?P<text>[^-]+)-$", sep)
        if (middle_text == None):
          text = "-"
        else:
          if (do_trace == 1):
            pprint.pprint (middle_text, tracefile)
            pprint.pprint (middle_text.groupdict(), tracefile)
          text = middle_text.groupdict() ["text"]
        while (len(text) < 5):
          text = text + "0"
        if (do_trace == 1):
          tracefile.write (
            "Return 5: " + the_digits + text + "-" + trail_digits + "\n")
        return the_digits + text + "-" + trail_digits
      if (do_trace == 1):
        tracefile.write (
          "Return 1: " + the_digits + sep1 + "0000-" + trail_digits + "\n")
      return the_digits + sep1 + "0000-" + trail_digits
    if (suffix == ""):
      suffix = "-"
    if (do_trace == 1):
      tracefile.write (
        "Return 2: " + the_digits + suffix + "0000-0000" + "\n")
    return the_digits + suffix + "0000-0000"
  if (do_trace == 1):
    tracefile.write (
      "Return 3: " + value + "-0000-0000" + "\n")
  return value + "-0000-0000"

# Reverse the above process.
# Page numbers are stored internally in a sortable format, consisting of
# a 4-digit number, a separator, a second 4-digit number, another separator
# and a third 4-digit number.  Format that into something nice to see.
# Note that if a number is all zeros it has probably been synthesized,
# so omit it.

def format_pageno (the_pageno):
  match_digits = re.match (
    "^(?P<lead_digits>[0-9]+)(?P<sep1>[^0-9]+)(?P<mid_digits>[0-9]+)" +
    "(?P<sep2>[^0-9]+)(?P<trail_digits>[0-9]+)$", the_pageno)
  if (match_digits):
    lead_digits = match_digits.groupdict() ["lead_digits"]
    sep1 = match_digits.groupdict() ["sep1"]
    mid_digits = match_digits.groupdict() ["mid_digits"]
    sep2 = match_digits.groupdict() ["sep2"]
    trail_digits = match_digits.groupdict() ["trail_digits"]
    if (do_trace == 1):
      tracefile.write ("Formatting " + the_pageno + ".\n")
      tracefile.write ("lead: " + lead_digits + ".\n")
      tracefile.write ("sep1: " + sep1 + ".\n")
      tracefile.write ("mid: " + mid_digits + ".\n")
      tracefile.write ("sep2: " + sep2 + ".\n")
      tracefile.write ("trail: " + trail_digits + ".\n")
    if ((mid_digits == "0000") and (sep2 == "-")):
      if ((trail_digits == "0000") and (sep1 == "-")):
        if (do_trace == 1):
          tracefile.write ("Return 1: " + str(int(lead_digits)) + "\n");
        return str(int(lead_digits))
      if (trail_digits == "0000"):
        if (do_trace == 1):
          tracefile.write ("Return 2: " + str(int(lead_digits)) + sep1 + "\n")
        return (str(int(lead_digits)) + sep1)
      if (sep2 == "-"):
        if (do_trace == 1):
          tracefile.write ("Return 6: " + str(int(lead_digits)) + sep1 +
                           str(int(trail_digits)) + "\n.")
        return (str(int(lead_digits)) + sep1 + str(int(trail_digits)))
      if (do_trace == 1):
            tracefile.write ("Return 3: " + str(int(lead_digits)) + sep1 +
                             sep2 + str(int(trail_digits)) + "\n")
      return (str(int(lead_digits)) + sep1 + sep2 + str(int(trail_digits)))
    if (do_trace == 1):
      tracefile.write ("Return 4: " +
                       str(int(lead_digits)) + sep1 +
                       str(int(mid_digits)) + sep2 +
                       str(int(trail_digits)) + "\n")
    return (str(int(lead_digits)) + sep1 + str(int(mid_digits)) + sep2 +
            str(int(trail_digits)))

current_page = "0000"
#
# The pages dictionary has an entry for each page.
# the index is the page number, the value is a
# dictionary.  This page-specific dictionary
# has keys "exit", and "quiet" which are lists
# of characters.
# "enter", "speaks" and "speaking" are lists of
# [character, speaks, group],
# where speaks is a code: 0 means does not speak
# and does not need a microphone.  1 means does not
# speak but needs a microphone because he speaks
# during this entrance.  2 means speaking on this
# page.  3 means speaks until quieted.
# 
# "intermission" and "end" are empty lists.
# "songs" is a list of song information for the
# page: each element is a two-element list,
# consisting of a song name and a code.
# Code 0 means the song ends on this page, 
# 1 means the song appears only on this page, and 
# 2 means the song starts on this page.
# "act" and "scene" are a list of the acts
# and scenes that start on this page.
# Only one of each is expected.
# "sounds" is a list of sound effects 
# for this page, coded the same as songs.
# "duration" is the time this page takes to perform,
# in seconds.
# "prompt" is the text to display so the mixer operator
# will know when this page starts.
#

# Start a page, or a part of a page
pages = {}
def page_start (value):
  global error_counter
  global current_page
  global pages
  previous_page = current_page
  current_page = make_pageno(value)
  if (current_page <= previous_page):
    print ("Pages must be described in order: " +
           format_pageno(current_page) + " is earlier than " +
           format_pageno(previous_page) + ".")
    error_counter = error_counter + 1
  if (current_page not in pages):
    pages [current_page] = {}
  return

def page_keyword_value (keyword, value):
  global error_counter
  the_page = pages[current_page]
  if (keyword == "prompt"):
    if ("prompt" in the_page):
      print ("More than one prompt for page " + format_pageno(current_page) +
             ".")
      error_counter = error_counter + 1
      return
    the_page["prompt"] = value
    return
  print ("Unknown page clause: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return

def page_end ():
  return

# Start an act
def act_start (act_name):
  this_page = pages [current_page]
  if ("act" not in this_page):
    this_page ["act"] = []
  this_page ["act"].append(act_name)
  return

def act_end ():
  return

# Start a scene
def scene_start (scene_name):
  this_page = pages [current_page]
  if ("scene" not in this_page):
    this_page ["scene"] = []
  this_page ["scene"].append(scene_name)
  return

def scene_end ():
  return

# sing a song on this page, or part of a page
def song_start (songname):
  this_page = pages [current_page]
  if ("songs" not in this_page):
    this_page ["songs"] = []
  the_songs = this_page ["songs"]
  the_songs.append ([songname, 1])
  return

def song_end ():
  return

# Make a sound on this page, or part of a page
def sound_start (soundname):
  this_page = pages [current_page]
  if ("sounds" not in this_page):
    this_page ["sounds"] = []
  the_sounds = this_page ["sounds"]
  the_sounds.append ([soundname, 1])
  return

def sound_end ():
  return

# This page, or part of a page, lasts this many seconds
def duration_start (duration_value):
  this_page = pages [current_page]
  if ("duration" not in this_page):
    this_page ["duration"] = []
  the_duration = this_page ["duration"]
  the_duration.append (int(duration_value))
  return

def duration_end ():
  return

# start a song or sound on this page, or part of a page
def begin_start (value):
  if (value[0:5] == "song "):
    songname = value[5:]
    this_page = pages [current_page]
    if ("songs" not in this_page):
      this_page ["songs"] = []
    the_songs = this_page ["songs"]
    the_songs.append ([songname, 2])
  elif (value[0:6] == "sound "):
    soundname = value[6:]
    this_page = pages [current_page]
    if ("sounds" not in this_page):
      this_page ["sounds"] = []
    the_sounds = this_page ["sounds"]
    the_sounds.append ([soundname, 2])
  else:
    print ("Bad begin: " + value)
    error_counter = error_counter + 1
  return

def begin_end ():
  return

# End a previously-started song or sound on this page,
#  or part of a page.  Also used for end of show.
def end_start (value):
  if (value[0:5] == "song "):
    songname = value[5:]
    this_page = pages [current_page]
    if ("songs" not in this_page):
      this_page ["songs"] = []
    the_songs = this_page ["songs"]
    the_songs.append ([songname, 0])
  elif (value == "show"):
    this_page = pages [current_page]
    this_page ["end"] = []
  elif (value[0:6] == "sound "):
    soundname = value[6:]
    this_page = pages [current_page]
    if ("sounds" not in this_page):
      this_page ["sounds"] = []
    the_sounds = this_page ["sounds"]
    the_sounds.append ([soundname, 0])
  else:
    print ("Bad end: " + value)
    error_counter = error_counter + 1
  return

def end_end ():
  return

# dictionary character_current_group is indexed by
# character name and holds the group that each
# character is in, while he is on stage.
character_current_group = {}

# a character enters the stage, or is heard off-stage
# each time a character enters he is in his default group
# unless specified otherwise
current_character_record = ""
def enter_start (value):
  global current_character_record
  global character_current_group
  this_page = pages [current_page]
  if ("enter" not in this_page):
    this_page ["enter"] = []
  the_enter_list = this_page ["enter"]
  if (value not in characters):
    the_character = {}
    the_character ["name"] = value
    the_character ["group"] = ""
    characters [value] = the_character
    print ("Character " + value + " is unknown.")
    error_counter = error_counter + 1
  the_character = characters [value]
  group = the_character ["group"]
  character_record = [the_character, 3, group]
  current_character_record = character_record
  the_enter_list.append (character_record)
  character_current_group [value] = group
  return

# during this appearance the character may not speak,
# and if he does he may be in a special group
def enter_keyword_value (keyword, value):
  global error_counter
  global current_character_record
  global groups
  global group_number
  the_character = current_character_record [0]
  character_name = the_character ["name"]
  if ((keyword == "speaks") and (value == "no")):
    current_character_record [1] = 0
    return
  group_name = value
  if (keyword == "group"):
    if ((DCA_style == "nosolo") and (group_name == "")):
      group_name = character_name
    current_character_record [2] = group_name
    character_current_group [character_name] = group_name
    if (group_name not in groups):
      if (do_trace == 1):
        tracefile.write ("Creating new group " + group_name +
                         " for character " + character_name + ".\n")
      group_dict = dict()
      group_dict["number"] = group_number
      group_dict["name"] = group_name
      group_number = group_number + 1
      groups[group_name] = group_dict
    return
  print ("Unknown enter clause: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return

def enter_end ():
  current_character_record = ""
  return

# the character speaks during this page, or part of a page
def speak_start (character_name):
  global current_character_record
  global error_counter
  if (character_name not in characters):
    print ("Character " + character_name + " is unknown.")
    error_counter = error_counter + 1
    return
  the_character = characters [character_name]
  if (character_name not in character_current_group):
    print ("Character " + character_name + " is not on stage to speak.")
    error_counter = error_counter + 1
    return
  group = character_current_group [character_name]
  character_record = [the_character, -1, group]
  this_page = pages [current_page]
  if ("speak" not in this_page):
    this_page ["speak"] = []
  the_speaks_list = this_page ["speak"]
  the_speaks_list.append(character_record)
  current_character_record = character_record
  return

# during this page, or part of a page, the character
# may be in a special group
def speak_keyword_value (keyword, value):
  global error_counter
  global current_character_record
  global groups
  global group_number
  if (keyword == "group"):
    character_record = current_character_record
    the_character = character_record [0]
    character_name = the_character ["name"]
    group_name = value
    if ((DCA_style == "nosolo") and (group_name == "")):
      group_name = character_name
    current_character_record [2] = group_name
    character_current_group [character_name] = group_name
    if (group_name not in groups):
      group_dict = dict()
      group_dict["number"] = group_number
      group_dict["name"] = group_name
      group_number = group_number + 1
      groups[group_name] = group_dict
    return
  print ("Unknown speak caluse: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return

def speak_end ():
  return

# the character begins speaking on this page, or part of
# a page, and does not stop until quieted
def speaking_start (character_name):
  global current_character_record
  the_character = characters [character_name]
  group = character_current_group [character_name]
  character_record = [the_character, -1, group]
  this_page = pages [current_page]
  if ("speaking" not in this_page):
    this_page ["speaking"] = []
  the_speaking_list = this_page ["speaking"]
  the_speaking_list.append(character_record)
  current_character_record = character_record
  return

# during this speaking interval the character
# may be in a special group
def speaking_keyword_value (keyword, value):
  global error_counter
  global current_character_record
  global groups
  global group_number
  if (keyword == "group"):
    character_record = current_character_record
    the_character = current_character_record [0]
    character_name = the_character ["name"]
    group_name = value
    if ((DCA_style == "nosolo") and (value == "")):
      group_name = character_name
    current_character_record [2] = group_name
    character_current_group [character_name] = group_name
    if (group_name not in groups):
      group_dict = dict()
      group_dict["number"] = group_number
      group_dict["name"] = group_name
      group_number = group_number + 1
      groups[group_name] = group_dict
    return
  print ("Unknown speaking clause: " + keyword + "=" + value)
  error_counter = error_counter + 1
  return

def speaking_end ():
  return

# The character does not speak for a while, so we can shut off
# the actor's microphone.
def quiet_start (character_name):
  the_character= characters [character_name]
  this_page = pages [current_page]
  if ("quiet" not in this_page):
    this_page ["quiet"] = []
  the_quiet_list = this_page ["quiet"]
  the_quiet_list.append(the_character)
  return

def quiet_end ():
  return

# The character leaves the stage, or stops speaking off-stage.
def exit_start (value):
  global character_current_group
  global error_counter
  this_page = pages [current_page]
  if ("exit" not in this_page):
    this_page ["exit"] = []
  the_exit_list = this_page ["exit"]
  the_character = characters [value]
  the_exit_list.append (the_character)
  if (value not in character_current_group):
    print ("Character " + value + " is not on stage so cannot exit.")
    error_counter = error_counter + 1
    return
  del character_current_group [value]
  return

def exit_end ():
  return

# The intermission is a good time to switch microphones.
def intermission_start (value):
  this_page = pages [current_page]
  this_page ["intermission"] = []
  return

def intermission_end ():
  return

# Parse the command line.
arguments = parser.parse_args ()
arguments = vars(arguments)

if (arguments ['trace'] != None):
  do_trace = 1
  trace_file_name = arguments ['trace']
  tracefile = open (trace_file_name, 'wt')

if (arguments ['verbose'] != None):
  verbosity_level = arguments ['verbose']

if (arguments ['output_root'] != None):
  output_root = arguments ['output_root']

if (arguments ['output_directory'] != None):
  output_directory = arguments ['output_directory']

file_name = arguments ['input_file']
if (output_directory == ""):
  output_directory = os.path.dirname(file_name)
  
if (output_root == ""):
  output_root = os.path.basename(file_name)

if (do_trace == 1):
  tracefile.write ("Starting; output to " +
                   os.path.join (output_directory, output_root) + "\n")
  
infile = open (file_name, 'rt')

for line in infile:
  if (re.match ("^\s*(//.*)?\n$", line)):
    continue;                   #  ignore blank lines and comments.
  matcha = re.match (
    "^\s*\[(?P<code>(\w)+)\s*(?P<value>(.)*)\]\s*(//.*)?\n$", line)
  if (matcha):
# This is a bracketed command, with a possible value before the
# right bracket
    code = matcha.groupdict() ['code']
    value = matcha.groupdict() ['value']
    if (current_code != ""):
      exec (current_code + "_end")
    current_code = code
    try:
      exec (current_code + "_start (value)")
    except NameError:
      print ("Command " + line.strip() + " not recognized.")
      current_code = ""
      error_counter = error_counter + 1
    continue
  matchc = re.match (
    "^\s*(?P<keyword>(\w)+)\s*=\s*(?P<value>(.)*)\s*(//.*)?\n$", line)
  if (matchc):
# This line has the form keyword = value
    keyword = matchc.groupdict () ['keyword']
    value = matchc.groupdict() ['value']
    if (do_trace == 1):
      tracefile.write ("Executing keyword " + keyword +
                       " with value " + value + ".\n")
    try:
      exec (current_code + "_keyword_value (keyword, value)")
    except NameError:
      print ("Command " + line.strip() + " not valid in a " +
             current_code + ".")
      error_counter = error_counter + 1
    continue
  print ("Unrecognized line: " + line.strip())
  error_counter = error_counter + 1
  break
infile.close()
#
# done reading the file, now process the data
#
page_list = list(pages)
page_list.sort()

if (do_trace):
  tracefile.write ("pages:" + "\n")
  pprint.pprint (page_list, tracefile)
  for the_page in page_list:
    tracefile.write ( "Page " + format_pageno (the_page) + "\n")
    pprint.pprint (pages [the_page], tracefile)
    tracefile.write (" " + "\n")
  tracefile.write ( "End of pages dictionary dump." + "\n")
  tracefile.write ("\n")

# 
# The activities dictionary describes the timeline for the show,
# by listing the activities that happen on each page.  The dictionary
# is indexed by page number, and the elements are a list of
# dictionaries.  Keys in these sub-dictionaties are "type", which
# is the type of activity being recorded: "song", "sound", "act" "scene",
# "actor".  "name" is the name of the song, act, scene or
# actor.  For song, act and scene the name is a string; for actor
# it is a reference to the actor's dictionary.  For actors, sounds and songs
# there is a third key, "duration", which specifies whether or not they
# continue to the next page: 1 means they do whereas 0 means they
# don't.
# type "duration" is the time, in seconds, to perform this page.
# type "start_time" is the time this page starts, in seconds.
# for duration and start_time, "value" is the value.
#

activities = {}
prev_page = ""
for page_number in page_list:
  this_page = pages [page_number]
# The first page starts empty.
  if (prev_page == ""):
    activities [page_number] = []
  else:
# Subsequent pages start with the non-expired items from the previous page.
    new_activities_list = []
    for old_activity in activities [prev_page]:
      new_activity = dict (old_activity)
      append_record = 1
      if (new_activity ["type"] == "duration"):
        append_record = 0
      if ("duration" in new_activity):
        if (new_activity ["duration"] == 0):
          append_record = 0
      if (new_activity["type"] == "prompt"):
        append_record = 0
      if (append_record == 1):
        new_activities_list.append(new_activity)
    activities [page_number] = new_activities_list
# process information specific to this page
  if ("songs" in this_page):
    song_list = this_page ["songs"]
    for song_record in song_list:
      song_name, code = song_record
# code 0 means stop, 1 means just this page, 2 means until stopped
      found_song = 0
      song_activity = dict (type = "song", name = song_name)
      for activity in activities [page_number]:
        if ((activity ["type"] == "song") and
            (activity ["name"] == song_name)):
          found_song = 1
          song_activity = activity
          break
      if (found_song == 1):
        if (song_activity ["duration"] == 1):
          if (code == 0):
            song_activity ["duration"] = 0
          else:
            print ("Already singing song " + song_name + " at page " +
                   format_pageno(page_number))
            error_counter = error_counter + 1
        else:
          print ("Strange command for song " + song_name + " at page " +
                 format_pageno(page_number))
          error_counter = error_counter + 1
      else:
        if (code == 1):
          song_activity ["duration"] = 0
        elif (code == 2):
          song_activity ["duration"] = 1
        else:
          print ("Not singing song " + song_name + " at page " +
                 format_pageno(page_number))
          error_counter = error_counter + 1
        activities[page_number].append(song_activity)

  if ("sounds" in this_page):
    sound_list = this_page ["sounds"]
    for sound_record in sound_list:
      sound_name, code = sound_record
# code 0 means stop, 1 means just this page, 2 means until stopped
      found_sound = 0
      sound_activity = dict (type = "sound", name = sound_name)
      for activity in activities [page_number]:
        if ((activity ["type"] == "sound") and
            (activity ["name"] == sound_name)):
          found_sound = 1
          sound_activity = activity
          break
      if (found_sound == 1):
        if (sound_activity ["duration"] == 1):
          if (code == 0):
            sound_activity ["duration"] = 0
          else:
            print ("Already making sound " + sound_name + " at page " +
                   format_pageno(page_number))
            error_counter = error_counter + 1
        else:
          print ("Strange command for sound " + sound_name + " at page " +
                 format_pageno(page_number))
          error_counter = error_counter + 1
      else:
        if (code == 1):
          sound_activity ["duration"] = 0
        elif (code == 2):
          sound_activity ["duration"] = 1
        else:
          print ("Not making sound " + sound_name + " at page " +
                 format_pageno(page_number))
          error_counter = error_counter + 1
        activities[page_number].append(sound_activity)

  if ("act" in this_page):
    act_list = this_page ["act"]
    for act_name in act_list:
      act_activity = dict (type = "act", name = act_name)
      found_act = 0
      for activity in activities [page_number]:
        if (activity ["type"] == "act"):
          found_act = 1
          act_activity = activity
          break
      if (found_act == 1):
        act_activity ["name"] = act_name
      else:
        activities[page_number].append(act_activity)

  if ("scene" in this_page):
    scene_list = this_page ["scene"]
    for scene_name in scene_list:
      scene_activity = dict (type = "scene", name = scene_name)
      found_scene = 0
      for activity in activities [page_number]:
        if (activity ["type"] == "scene"):
          found_scene = 1
          scene_activity = activity
          break
      if (found_scene == 1):
        scene_activity ["name"] = scene_name
      else:
        activities[page_number].append(scene_activity)

  if ("duration" in this_page):
    duration_list = this_page ["duration"]
    for duration_value in duration_list:
      duration_activity = dict (type = "duration", value = duration_value)
      found_duration = 0
      for activity in activities [page_number]:
        if (activity ["type"] == "duration"):
          found_duration = 1
          duration_activity = activity
          break
      if (found_duration == 1):
        duration_activity ["value"] = duration_value
      else:
        activities [page_number].append(duration_activity)

  if ("prompt" in this_page):
    prompt_activity = dict (type = "prompt", text = this_page["prompt"])
    activities [page_number].append(prompt_activity)
      
  prev_page = page_number
  
if (do_trace == 1):
  tracefile.write ("Activities, before actors:" + "\n")
  pprint.pprint (activities, tracefile)
  tracefile.write (" " + "\n")

#
# The on_stage dictionary is indexed by page.  The value
# corresponding to a page is a list of sequences.
# Each sequence consists of an actor who is on-stage,
# the character he is playing, a flag specifying whether
# or not the character speaks, and his microphone group.
# Speaks == 0 means the character does not speak and does not
#  need a microphone.
# Speaks == 1 means the character does not speak on this page,
#  but needs a microphone because he speaks on other pages in
#  this same entrance.
# Speaks == 2 means the character is speaking on this page, but
#  not on the next unless specifically flagged.
# Speaks == 3 means the character is speaking and will continue
#  to speak unless specifically flagged as quiet.
on_stage = {}
prev_pageno = ""
for pageno in page_list:
  if (do_trace == 1):
    tracefile.write ("Starting page " + pageno + "\n")
  this_page = pages [pageno]
# the first page starts empty.  Subsequent pages start with a
# copy of what remains from the previous page.
  if (prev_pageno == ""):
    on_stage [pageno] = []
  else:
# Actors noted as having spoken on the previous page revert to
# non-speaking on this page, unless specifically so noted again.  
    new_actor_list = []
    old_actor_list = on_stage [prev_pageno]
    for old_actor_record in old_actor_list:
      new_actor_record = [old_actor_record [0],
                          old_actor_record [1],
                          old_actor_record [2],
                          old_actor_record [3]]
      if (new_actor_record [2] == 2):
        new_actor_record [2] = 1
      new_actor_list.append(new_actor_record)
    on_stage [pageno] = new_actor_list
  if (do_trace == 1):
    tracefile.write ("Actors already on stage:\n")
    pprint.pprint (on_stage[pageno], tracefile)
# process entrances first
  if ("enter" in this_page):
    the_enter_list = this_page ["enter"]
    if (do_trace == 1):
      pprint.pprint (the_enter_list, tracefile)
    for [the_character, speaks, group] in the_enter_list:
      the_actor = find_actor(the_character ["name"])
      if (do_trace == 1):
        tracefile.write ("Actor " + the_actor ["name"] +
                         " enters as " + the_character["name"] +
                         "\n")
      actor_list = on_stage [pageno]
      actor_list.append ([the_actor, the_character, speaks, group])
# update the speaking state for actors who are on stage
  if ("speak" in this_page):
    the_speak_list = this_page ["speak"]
    if (do_trace == 1):
      pprint.pprint (the_speak_list, tracefile)
    for [the_character, speaks, group] in the_speak_list:
      character_found = 0
      for actor_record in on_stage [pageno]:
        the_actor, other_character, old_speaks, old_group = actor_record
        if (other_character == the_character):
          character_found = 1
          break
      if (character_found == 0):
        print ("Character " + the_character ["name"] +
               " is not on stage to speak at page " +
               format_pageno(pageno))
        error_counter = error_counter + 1
      else:
        if (actor_record [2] > 0):
          if (do_trace == 1):
            tracefile.write ("Actor " + the_actor ["name"] +
                             " speaks as " + the_character["name"] + "\n")
          actor_record [2] = 2
        actor_record [3] = group
  if ("speaking" in this_page):
    the_speaking_list = this_page ["speaking"]
    if (do_trace == 1):
      pprint.pprint (the_speaking_list, tracefile)
    for [the_character, speaks, group] in the_speaking_list:
      character_found = 0
      if (do_trace == 1):
        tracefile.write ("Speaking " + the_character["name"] + "\n")
      for actor_record in on_stage [pageno]:
        the_actor, other_character, old_speaks, old_group = actor_record
        if (other_character == the_character):
          character_found = 1
          break
      if (character_found == 0):
        print ("Character " + the_character ["name"] +
               " is not on stage to start speaking at page " +
               format_pageno(pageno))
        error_counter = error_counter + 1
      else:
        if (actor_record [2] > 0):
          if (do_trace == 1):
            tracefile.write ("Actor " + the_actor ["name"] +
                             " starts speaking as " + 
                             the_character["name"] + "\n")
          actor_record [2] = 3
        actor_record [3] = group
  if ("quiet" in this_page):
    the_quiet_list = this_page ["quiet"]
    if (do_trace == 1):
      tracefile.write ("quiet list:\n")
      pprint.pprint (the_quiet_list, tracefile)
    for the_character in the_quiet_list:
      character_found = 0
      for actor_record in on_stage [pageno]:
        the_actor, other_character, old_speaks, old_group = actor_record
        if (other_character == the_character):
          character_found = 1
          break
      if (character_found == 0):
        print ("Character " + the_character ["name"] +
               " is not on stage to stop speaking at page " + 
               format_pageno(pageno))
        error_counter = error_counter + 1
      else:
        if (do_trace == 1):
          tracefile.write ("Quieting " + the_character ["name"] + "\n")
          pprint.pprint (actor_record, tracefile)
        if (actor_record [2] > 0):
          if (do_trace == 1):
            tracefile.write ("Actor " + the_actor ["name"] +
                             " stops speaking as " + 
                             the_character["name"] + "\n")
          actor_record [2] = 1
# now process exits
  if ("exit" in this_page):
    the_exit_list = this_page ["exit"]
    if (do_trace == 1):
      pprint.pprint (the_exit_list, tracefile)
    for the_character in the_exit_list:
      character_found = 0
      for actor_record in on_stage [pageno]:
        the_actor, other_character, speaks, group = actor_record
        if (other_character == the_character):
          character_found = 1
          break
      if (character_found == 0):
        print ("Character " + the_character ["name"] +
               " is not on stage to exit at page " + 
               format_pageno(pageno))
        error_counter = error_counter + 1
      else:
        if (do_trace == 1):
          tracefile.write ("Actor " + the_actor ["name"] +
                           " exits as " +
                           the_character["name"] + "\n")
        actor_list = on_stage [pageno]
        actor_list.remove (actor_record)
  if ("intermission" in this_page):
    actor_list = on_stage [pageno]
    for [the_actor, the_character, speaks, group] in actor_list:
      print ("Actor " + the_actor ["name"] +
             " is still on stage as " + 
             the_character ["name"] +
             " at intermission.")
      error_counter = error_counter + 1
  if ("end" in this_page):
    actor_list = on_stage [pageno]
    for [the_actor, the_character, speaks, group] in actor_list:
      print ("Actor " + the_actor ["name"] +
             " is still on stage as " + 
             the_character ["name"] + " at end.")
      error_counter = error_counter + 1
  if (do_trace == 1):
    tracefile.write ("End of page " + pageno + "\n")
    #pprint.pprint (on_stage, tracefile))
  prev_pageno = pageno
#
# Add the actors to the activities dictionary.
#
for page_number in page_list:
  actor_list = on_stage [page_number]
  activities_list = activities [page_number]
  for the_actor, the_character, speaks, group in actor_list:
    actor_activity = dict (type = "actor", name = the_actor)
    if (speaks == 0):
      actor_activity ["speaks"] = " (no microphone)"
    elif (speaks == 1):
      actor_activity ["speaks"] = " (silent)"
    actor_activity ["group"] = group
    activities_list.append (actor_activity)

if (do_trace == 1):
  tracefile.write ("Activities, after actors:" + "\n")
  pprint.pprint (activities, tracefile)
  tracefile.write (" " + "\n")

#
# Assign a duration to each page.  Pages are assumed to take 72 seconds
# unless otherwise marked.  A page divided into sections is presumed to
# take 72/<number of sections>, rounded up to the nearest second,
# for each section unless otherwise marked.
#
for page_number in page_list:
  page_activities_list = activities [page_number]
  numeric_page_number = page_number [0:4]
  page_count = 0
  for other_page_number in page_list:
    numeric_other_page_number = other_page_number [0:4]
    if (numeric_page_number == numeric_other_page_number):
      page_count = page_count + 1
  duration_found = 0
  for activity in page_activities_list:
    if (activity ["type"] == "duration"):
      duration_found = 1
      break
  if (duration_found == 0):
    duration_value = 72 / page_count
    int_duration_value = round (duration_value)
    if (int_duration_value < duration_value):
      int_duration_value = int_duration_value + 1
    duration_activity = dict (type = "duration")
    duration_activity ["value"] = int_duration_value
    page_activities_list.append(duration_activity)

#
# Compute the start time of each page.
#
prev_page_number = ""
for page_number in page_list:
  page_activities_list = activities [page_number]
  numeric_page_number = int(page_number [0:4])
  if (prev_page_number != ""):
    prev_page_activities_list = activities [prev_page_number]
    prev_start_time_found = 0
    for activity in prev_page_activities_list:
      if (activity ["type"] == "start_time"):
        prev_page_start_time = activity ["value"]
        prev_start_time_found = 1
        break
    if (prev_start_time_found == 0):
      prev_page_start_time = 0
    prev_duration_found = 0
    for activity in prev_page_activities_list:
      if (activity ["type"] == "duration"):
        prev_page_duration = activity ["value"]
        prev_page_duration_found = 1
        break
    if (prev_page_duration_found == 0):
      prev_page_duration = 120
    this_page_start_time = prev_page_start_time + prev_page_duration
    numeric_prev_page_number = int(prev_page_number [0:4])
    while ((numeric_prev_page_number + 1) < numeric_page_number):
      this_page_start_time = this_page_start_time + 120
      numeric_prev_page_number = numeric_prev_page_number + 1
  else:
    this_page_start_time = 0
  start_time_activity = dict (type = "start_time")
  start_time_activity ["value"] = this_page_start_time
  page_activities_list.append (start_time_activity)
  if (do_trace):
    tracefile.write ("Page " + page_number + " starts at " + 
      str(this_page_start_time) + " seconds." + "\n")
  prev_page_number = page_number

# Print the total time of the performance
#
total_time = 0
if (len(page_list) > 0):
  last_page = page_list [-1]
  last_page_activities_list = activities [last_page]
  for activity in last_page_activities_list:
    if (activity ["type"] == "start_time"):
      last_page_start_time = activity ["value"]
    if (activity ["type"] == "duration"):
      last_page_duration = activity ["value"]
  total_time = last_page_start_time + last_page_duration
  if (verbosity_level > 0):
    print ("Total time is " + str(round(total_time / 60)) + " minutes.")


# To make microphone instructions easier for actors to understand,
# we will use song names to describe times in the show.  Record
# the last song before each page and the first song after each
# page, so we can relate pages to songs.
# These dictionaties are indexed by page number and contain the
# name of the song.
#
song_before_page = dict ()
song_after_page = dict ()
song_during_page = dict ()
for page_number in page_list:
  page_activities = activities [page_number]
  for activity in page_activities:
    if (activity ["type"] == "song"):
      song_name = activity ["name"]
      song_during_page [page_number] = song_name
last_song = ""
for page_number in page_list:
  song_before_page [page_number] = last_song
  if (page_number in song_during_page):
    last_song = song_during_page [page_number]
prev_song = ""
for page_number in reversed(page_list):
  if (page_number in song_during_page):
    prev_song = song_during_page [page_number]
  song_after_page [page_number] = prev_song

if (do_trace == 1):
  tracefile.write ("song during page:" + "\n")
  pprint.pprint (song_during_page, tracefile)
  tracefile.write ("\n")
  tracefile.write ("song before page:" + "\n")
  pprint.pprint (song_before_page, tracefile)
  tracefile.write ("\n")
  tracefile.write ("song after page:" + "\n")
  pprint.pprint (song_after_page, tracefile)
  tracefile.write ("\n")
  

def quote_for_tex (text):
  fixed_text_1 = text.replace ("#", "\\#")
  fixed_text_2 = fixed_text_1.replace ("&", "\\&")
  fixed_text_3 = fixed_text_2.replace (". ", ".~")
  fixed_text_4 = fixed_text_3.replace ("_", "\\_")
  return fixed_text_4

def quote_for_X32TC (text):
  fixed_text_1 = text.replace ("'", "''")
  return fixed_text_1

def actor_expanded_name (the_actor):
  the_name = the_actor ["name"]
  the_rolls = rolls [the_name]
  roll_names = ""
  for the_character in the_rolls:
    if (len(roll_names) == 0):
      roll_names = the_character ["name"]
    else:
      roll_names = roll_names + " and " + the_character ["name"]
  return the_name + " as " + roll_names

def seconds_to_hhmmss (value):
  hours = int(value / 3600)
  seconds = value - (hours * 3600)
  minutes = int (seconds / 60)
  seconds = value - (hours * 3600) - (minutes * 60)
  return (str(hours).zfill(2) +
          ":" +
          str(minutes).zfill(2) +
          ":" +
          str(seconds).zfill(2))

if (do_trace == 1):
  tracefile.write ("Microphone groups:\n")
  pprint.pprint (groups, tracefile)

# Output a summary of the show's timeline.
#
listfile = open (os.path.join(output_directory, output_root) +
                              ".activities.tex", "wt")
cue_number = 0 
for page_number in page_list:
  cue_number = cue_number + 1
  act_name = ""
  scene_name = ""
  start_time = ""
  duration = ""
  prompt = ""
  activity_list = activities [page_number]
  for activity_item in activity_list:
    type = activity_item ["type"]
    if (type == "act"):
      act_name = activity_item["name"]
    elif (type == "scene"):
      scene_name = activity_item["name"]
    elif (type == "start_time"):
      start_time = int(activity_item ["value"])
    elif (type == "duration"):
      duration = int(activity_item ["value"])
    elif (type == "prompt"):
      prompt = activity_item["text"]
      
  listfile.write ("\\subsection{" + str(cue_number).zfill(3) +
                  ": Act " + quote_for_tex(act_name) +
                  " Scene " + quote_for_tex(scene_name) +
                  " Page ")
  listfile.write (quote_for_tex(format_pageno(page_number)))
  listfile.write (" Start time " + seconds_to_hhmmss(start_time))
  listfile.write (" Duration " + seconds_to_hhmmss(duration))
  if (prompt != ""):
    listfile.write (" Prompt " + quote_for_tex(prompt))
  listfile.write ("}\n")
#
# Write actor, song and sound information for this cue.
  first_group = 1
  for the_group in groups:
    first_actor = 1
    for the_actor in actors:
      for activity_item in activity_list:
        if (activity_item ["type"] == "actor"):
#
# Write actor information for this cue.
          if ((activity_item ["name"] == the_actor) and
              (activity_item ["group"] == the_group)):
            if (first_group == 1):
              first_group = 0
              listfile.write ("\n")
            if (first_actor == 1):
              first_actor = 0
              if (the_group == ""):
                listfile.write ("\\subsubsection{Actors}\n")
              else:
                listfile.write ("\\subsubsection{Actors in group " +
                              quote_for_tex(the_group) + "}\n")
              listfile.write ("\\begin{enumerate}\n")
            listfile.write ("\\item " +
                            quote_for_tex(actor_expanded_name (the_actor)))
            if ("speaks" in activity_item):
              listfile.write (activity_item["speaks"])
            listfile.write ("\n");
    if (first_actor == 0):
      listfile.write ("\\end{enumerate}\n")
  if (first_group == 0):
    listfile.write ("\n")
#
# Write song information for this cue.
  first_song = 1
  for activity_item in activity_list:
    if (activity_item ["type"] == "song"):
      if (first_song == 1):
        first_song = 0
        listfile.write ("\\subsubsection{Songs}\n\\begin{enumerate}\n")
      listfile.write ("\\item " +
                      quote_for_tex(activity_item ["name"]) +
                      "\n")
  if (first_song == 0):
    listfile.write ("\\end{enumerate}")
#
# Write sound information for this cue.
  first_sound = 1
  for activity_item in activity_list:
    if (activity_item ["type"] == "sound"):
      if (first_sound == 1):
        first_sound = 0
        listfile.write ("\\subsubsection{Sounds}\n\\begin{enumerate}\n")
      listfile.write ("\\item " +
                      quote_for_tex(activity_item["name"]) +
                      "\n")
  if (first_sound == 0):
    listfile.write ("\\end{enumerate}")
  listfile.write ("\n")
listfile.close()
  
if (do_trace == 1):
  tracefile.write ("Actors:" + "\n")
  pprint.pprint (actors, tracefile)
  tracefile.write ("\n")
  tracefile.write ("On_stage:" + "\n")
  pprint.pprint (on_stage, tracefile)
  tracefile.write ("\n")

#
# Output a CSV file with actors in columns and pages in rows.
# If the actor has a microphone on that page, output a "*"
# or the microphone's group; otherwise output a " "
#
listfile = open (os.path.join(output_directory, output_root) + ".csv", "wt")
listfile.write ("page")
column = 0
for the_actor in actors:
  column = column + 1
  the_actor ["column"] = column
  listfile.write (', "' + the_actor ["name"] + '"')
listfile.write ("\n")
  
for pageno in page_list:
  listfile.write ('"' + format_pageno(pageno) + '"')
  for the_actor in actors:
    actor_found = 0
    actor_speaks = 0
    for [other_actor, the_character, speaks, group] in on_stage [pageno]:
      if (other_actor == the_actor):
        if (speaks > 0):
          actor_speaks = 1
          break
    if (actor_speaks == 1):
      if (group != ""):
        listfile.write (',"' + group + '"')
      else:
        listfile.write (',"*"')
    else:
      listfile.write ('," "')
  listfile.write ("\n")
listfile.close()

# Go through the timeline, assigning a microphone to each actor
# who enters, and removing it when he exits.  Create a new
# microphone when necessary, but re-use old ones whenever
# possible.  
#

# The minimum number of microphones required is the maximum
# number of speaking actors on stage simultaneously.
# Start with that many microphones available; we will add to
# that list if necessary.

max_microphone = 0
max_microphone_pageno = ""
for pageno in page_list:
  speaking_actors = set ()
  microphone_count = 0
  for [the_actor, the_character, speaks, group] in on_stage [pageno]:
    if (speaks > 0):
      speaking_actors.add (the_actor ["name"])
      microphone_count = len (speaking_actors)
  if (microphone_count > max_microphone):
    max_microphone_pageno = pageno
    max_microphone = microphone_count

if ((verbosity_level > 0) and (max_microphone_pageno != "")):
  print ("Minimum of " +
         str(max_microphone) +
         " microphones required on page " + 
         format_pageno(max_microphone_pageno))

# Provide a little more than the minimum.
max_microphone = max_microphone + extra_microphones

# If the number of microphones was specified in the input file, use that number.
if (microphone_limit != 0):
  max_microphone = microphone_limit

# microphone_info is a dictionary indexed by microphone number.  It holds
# the last actor to wear the microphone, and the time it was removed from him.
microphone_info = {}

microphones = []
for the_microphone in range (1,max_microphone+1):
  microphones.append(the_microphone)
  microphone_info [the_microphone] = dict (number = the_microphone, 
    last_actor = "", removal_time = 0)

min_microphone_switching_time = total_time
min_microphone_switching_time_page = ""

# Assign a microphone to an actor.
# It is best if an actor always wears the same microphone.
# 
def assign_microphone (an_actor, current_page):
  global max_microphone
  global min_microphone_switching_time
  global min_microphone_switching_time_page
  if (do_trace):
    tracefile.write ("Assign a microphone to " +
                     an_actor ["name"] + "\n")
  the_microphone = 0
  for activity in activities [current_page]:
    if (activity ["type"] == "start_time"):
      current_time = activity ["value"]
      break
  if (len(microphones) == 0):
    if (do_trace == 1):
      tracefile.write ("Allocate another microphone." + "\n")
    max_microphone = max_microphone + 1
    microphone_info [max_microphone] = dict (number = max_microphone, 
      last_actor = "", removal_time = 0)
    microphones.append(max_microphone)
  if (do_trace):
    pprint.pprint (microphones, tracefile)
# If the actor previously wore a microphone, try to get it back
# for him provided there has been enough time to switch
# microphones from its previous wearer
  if (an_actor ["old_microphone"] in microphones):
    possible_microphone = an_actor ["old_microphone"]
    if (possible_microphone not in microphone_info):
      microphone_info [possible_microphone] = dict (
        number = possible_microphone, last_actor = "",
        removal_time = 0)
    possible_microphone_info = microphone_info [possible_microphone]
    last_actor = possible_microphone_info ["last_actor"]
    delta_time = current_time - possible_microphone_info ["removal_time"]
    if ((delta_time > microphone_switch_time) or
        ((last_actor == "") or (last_actor == an_actor))):
      if (do_trace == 1):
        tracefile.write ("Actor " + the_actor ["name"] +
                         " gets his old microphone back" + "\n")
      the_microphone = possible_microphone
      microphones.remove(the_microphone)
    else:
      if (do_trace):
        last_actor = possible_microphone_info ["last_actor"]
        tracefile.write ("Actor " + the_actor ["name"] +
                         " cannot get his old microphone back" +
                         " because actor " + last_actor ["name"] +
                         " was wearing it too recently." + "\n")
  if (the_microphone == 0):
# Otherwise, look for a microphone not previously worn.
    if (do_trace):
      tracefile.write ("Actors: " + str(actors))
    for other_microphone in microphones:
      microphone_was_used = 0
      for other_actor in actors:
        if ("old_microphone" not in other_actor):
          pprint.pprint (other_actor)
        if (other_actor ["old_microphone"] == other_microphone):
          microphone_was_used = 1
          break
      if (microphone_was_used == 0):
        the_microphone = other_microphone
        if (do_trace == 1):
          tracefile.write ("Actor " + the_actor ["name"] +
                           " gets an unused microphone" + "\n")
        microphones.remove(the_microphone)
        break
  if (the_microphone == 0):
# Otherwise, take the oldest microphone from an actor who has
# left the stage for the last time, provided there has been
# enough time to switch microphones.
    for other_microphone in microphones:
      microphone_still_needed = False
      other_microphone_info = microphone_info [other_microphone]
      if (do_trace):
        pprint.pprint (other_microphone_info, tracefile)
      delta_time = current_time - other_microphone_info ["removal_time"]
      if (delta_time < microphone_switch_time):
        continue
      for other_actor in actors:
        if ((other_actor ["old_microphone"] == other_microphone) and
            (other_actor ["reenters"])):
          microphone_still_needed = True
          break
      if (not microphone_still_needed):
        the_microphone = other_microphone
        if (do_trace == 1):
          last_actor = other_microphone_info ["last_actor"]
          tracefile.write ("Actor " + the_actor ["name"] +
                           " gets a microphone from " + 
                           last_actor ["name"] +
                           " who has left the stage for the last time" + "\n")
        microphones.remove(the_microphone)
        break
  if (the_microphone == 0):
# Otherwise, look for a microphone on an actor who will be
# off-stage until intermission, provided, again, that there
# has been enough time to switch microphones.
    for other_microphone in microphones:
      microphone_still_needed = False
      other_microphone_info = microphone_info [other_microphone]
      if (do_trace):
        pprint.pprint (other_microphone_info, tracefile)
      delta_time = current_time - other_microphone_info ["removal_time"]
      if (delta_time < microphone_switch_time):
        continue
      for other_actor in actors:
        if ((other_actor ["old_microphone"] == other_microphone) and 
          (other_actor ["reenters_before_intermission"])):
          microphone_still_needed = True
          break
      if (not microphone_still_needed):
          the_microphone = other_microphone
          if (do_trace == 1):
            last_actor = other_microphone_info ["last_actor"]
            tracefile.write ("Actor " + the_actor ["name"] +
                             " gets a microphone from " + 
                             last_actor ["name"] +
                             " who has left the stage until intermission" +
                             "\n")
          microphones.remove(the_microphone)
          break
  if (the_microphone == 0):
# Otherwise, take the oldest microphone available.
    the_microphone = microphones.pop(0)
    if (do_trace == 1):
      tracefile.write ("Actor " + the_actor ["name"] + 
                       " gets the oldest microphone available" + "\n")
  an_actor ["microphone"] = the_microphone
  the_microphone_info = microphone_info [the_microphone]
  delta_time = current_time - the_microphone_info ["removal_time"]
  last_actor = the_microphone_info ["last_actor"]
  if ((last_actor != "") and (last_actor != an_actor)):
    if (delta_time < min_microphone_switching_time):
      min_microphone_switching_time = delta_time
      min_microphone_switching_time_page = current_page
  if (do_trace == 1):
    tracefile.write ("Actor " + an_actor["name"] +
                     " gets microphone " + 
                     str(the_microphone) + " on page " +
                     str(current_page) + "\n")
  return

# An actor no longer needs a microphone.
#
def remove_microphone (an_actor, current_page):
  the_microphone = an_actor ["microphone"]
# if this actor is leaving the stage for the last time, his
# microphone has higher priority to be given to a different
# actor than if he is returning.  Similarly, the microphone
# has intermediate priority if the actor will not be
# re-entering before the next itermission.
  will_reenter = False
  will_reenter_before_intermission = False
  intermission_encountered = False
  found_reentry = False
  for pageno in page_list:
    if (pageno > current_page):
      if ("intermission" in pages [pageno]):
        intermission_encountered = True
      actor_found = 0
      for [other_actor, the_character, speaks, group] in on_stage [pageno]:
        if ((other_actor == an_actor) and (speaks > 0)):
          will_reenter = True
          will_reenter_before_intermission = not intermission_encountered
          found_reentry = True
          break
      if (found_reentry):
        break
  an_actor ["old_microphone"] = an_actor ["microphone"]
  an_actor ["microphone"] = 0
  an_actor ["reenters"] = will_reenter
  an_actor ["reenters_before_intermission"] = will_reenter_before_intermission
  microphones.append (the_microphone)
  this_microphone_info = microphone_info [the_microphone]
  this_microphone_info ["last_actor"] = an_actor
  for activity in activities [current_page]:
    if (activity ["type"] == "start_time"):
      page_start_time = activity ["value"]
    if (activity ["type"] == "duration"):
      page_duration = activity ["value"]
  this_microphone_info ["removal_time"] = page_start_time + page_duration
  if (do_trace == 1):
    tracefile.write ("Actor " + an_actor ["name"] +
                     " loses microphone " + 
                     str(the_microphone) + " on page " +
                     str(current_page) + ";\n")
    if (not will_reenter):
      tracefile.write (" he will not need a microphone again" + "\n")
    elif (not will_reenter_before_intermission):
      tracefile.write (" he will not need a microphone before intermission" +
                       "\n")
  return

# microphone_log is a dictionary keyed by microphone number.
# values are lists of (actor, page, group) for this microphone.
microphone_log = {}

# microphone_switching_log is a dictionary keyed by page
# number.  Values are lists of microphones that must
# be switched on during this page.
microphone_switching_log = {}

# page_log is a dictionary keyed by page number.
# values are lists of (actor, microphone, group) for this page.
page_log = {}

# the actor log is kept by actor, and is a list of
# [page, microphone, group].
for the_actor in actors:
  the_actor ["log"] = []
  the_actor ["microphone"] = 0
  the_actor ["group"] = ""

# actors_by_entrance is a list of actors sorted by their first
# entrance with a microphone.
actors_by_entrance = []

for pageno in page_list:
  for the_actor in actors:
    for [other_actor, the_character, speaks, group] in on_stage[pageno]:
      if ((other_actor == the_actor) and (speaks > 0)):
        the_actor ["group"] = group
# actors returning to the stage and speaking need microphones
        if (the_actor ["microphone"] == 0):
          if ("old_microphone" in the_actor):
            assign_microphone (the_actor, pageno)
        break
  for the_actor in actors:
# actors entering the stage for the first time and speaking get microphones
    for [other_actor, the_character, speaks, group] in on_stage[pageno]:
      if ((other_actor == the_actor) and (speaks > 0)):
        the_actor ["group"] = group
        if (the_actor not in actors_by_entrance):
          actors_by_entrance = actors_by_entrance + [the_actor]
        if (the_actor ["microphone"] == 0):
          assign_microphone (the_actor, pageno)
  for the_actor in actors:
# log microphone usage by microphone, by page and by actor
    this_microphone = the_actor ["microphone"]
    if (this_microphone != 0):
      microphone_record = [the_actor, pageno, the_actor ["group"]]
      if (this_microphone not in microphone_log):
        microphone_log [this_microphone] = []
      microphone_log [this_microphone].append(microphone_record)
      if (do_trace == 1):
        tracefile.write ("Microphone log entry: " + str(this_microphone) + "\n")
        pprint.pprint (microphone_record, tracefile)
      page_record = [the_actor, this_microphone, the_actor ["group"]]
      if (pageno not in page_log):
        page_log [pageno] = []
      page_log [pageno].append(page_record)
      actor_log = the_actor ["log"]
      actor_record = [pageno, this_microphone, the_actor ["group"]]
      actor_log.append(actor_record)
# note which microphones must be switched on for this page
  for [the_actor, the_character, speaks, group] in on_stage[pageno]:
    if (speaks > 1):
      the_microphone = the_actor ["microphone"]
      if (pageno not in microphone_switching_log):
        microphone_switching_log [pageno] = []
      microphone_switching_list = microphone_switching_log [pageno]
      if (the_microphone not in microphone_switching_list):
        microphone_switching_list.append(the_microphone)
# actors leaving the stage will no longer need their microphones
  for the_actor in reversed(actors):
    if (the_actor ["microphone"] != 0):
      actor_found = 0
      for [other_actor, the_character, speaks, group] in on_stage [pageno]:
        if ((other_actor == the_actor) and (speaks > 0)):
          actor_found = 1
          break
      if (actor_found == 0):
        remove_microphone (the_actor, pageno)

if (do_trace):
  tracefile.write ("Microphone_info:" + "\n")
  pprint.pprint (microphone_info, tracefile)
  tracefile.write ("\n")
  tracefile.write ("Actors by entrance: " + "\n")
  pprint.pprint (actors_by_entrance, tracefile)
  tracefile.write ("\n")

if (verbosity_level > 0):
  if (min_microphone_switching_time_page != ""):
    print ("Minimum microphone switching time is " +
           str(min_microphone_switching_time) +
           " on page " +
           format_pageno(min_microphone_switching_time_page) +
           ".")

#
# Character_log remembers which characters are speaking on each page,
# which actor is being the character, which microphone the actor
# is using, which group he is in and the name of one of the underlying
# characters.  Note that an actor may be more than one character.
#
# Character_log is indexed by page and microphone.  The value is a list
# with these items:
# 0 = composite character names
# 1 = actor
# 2 = group
# 3 = list of names of characters
character_log = dict()

for the_microphone in range (1,max_microphone+1):
  if (the_microphone in microphone_log):
    for [the_actor, the_page, the_group] in microphone_log [the_microphone]:
      for [an_actor, the_character, speaks, a_group] in on_stage [the_page]:
        if ((an_actor == the_actor) and (speaks > 1)):
          old_name = ""
          old_character_names = list()
          if (the_page, the_microphone) in character_log:
            old_name = character_log [the_page, the_microphone][0] + " and "
            old_character_names = character_log [the_page, the_microphone][3]
          character_log [the_page, the_microphone] = \
            (old_name + the_character["name"], the_actor, the_group,
             old_character_names + [the_character["name"]])
             

if (do_trace):
  tracefile.write ("Character_log:\n")
  pprint.pprint (character_log, tracefile)
  tracefile.write ("\n")
  
if (do_trace):
  tracefile.write ("Microphone_log before collapse:" + "\n")
  pprint.pprint (microphone_log, tracefile)
  tracefile.write ("\n")

# microphone_group is a dictionary indexed by page and
# microphone number containing the name of the microphone's
# group at that page.
#
microphone_group = {}

for the_microphone in range (1,max_microphone+1):
  if (the_microphone in microphone_log):
    for [an_actor, pageno, group] in microphone_log [the_microphone]:
      microphone_group [(pageno, the_microphone)] = group

if (do_trace):
  tracefile.write ("Microphone_group:" + "\n")
  pprint.pprint (microphone_group, tracefile)
  tracefile.write ("\n")

# Collapse the microphone log into page ranges instead of
# individual pages.  We will lose the group information
# but it has been captured in microphone_group above.
for the_microphone in range (1,max_microphone+1):
  if (the_microphone not in microphone_log):
    microphone_log [the_microphone] = []
  this_microphone_log = microphone_log [the_microphone]
  new_microphone_log = []
  first_entry = 1
  for log_entry in this_microphone_log:
    this_actor = log_entry [0]
    this_page = format_pageno (log_entry [1])
    this_group = log_entry [2]
    if (first_entry == 1):
      prev_actor = this_actor
      prev_page = this_page
      prev_group = this_group
    else:
      if (this_actor == prev_actor):
        if (prev_page.count("-") != 0):
          prev_page = prev_page.split("-")[0] + "-" + this_page
        else:
          prev_page = prev_page + "-" + this_page
      else:
        new_entry = [prev_actor, prev_page]
        new_microphone_log.append(new_entry)
        prev_actor = this_actor
        prev_page = this_page
        prev_group = this_group
    first_entry = 0
  if (first_entry == 0):
    new_entry = [prev_actor, prev_page, prev_group]
    new_microphone_log.append(new_entry)
    microphone_log [the_microphone] = new_microphone_log

if (do_trace):
  tracefile.write ("Microphone_log after collapse:" + "\n")
  pprint.pprint (microphone_log, tracefile)
  tracefile.write ("\n")

def reformat_page_range (ranges):
  return_value = ""
  first_range = 1
  for the_range in ranges:
    pages = the_range.split("-")
    if (first_range == 0):
      return_value = return_value + ", "
    else:
      first_range = 0
    return_value = return_value + pages[0] + " to " + pages[1]
  return return_value

# Output microphone assignments by microphone number and actor entrance.

listfile = open (os.path.join (output_directory, output_root) +
                 ".assignments.tex", "wt")
for the_microphone in range (1,max_microphone+1):
  this_microphone_log = microphone_log [the_microphone]
  if (len(this_microphone_log) == 0):
    continue
  listfile.write (str(the_microphone) + "&")
  listfile.write ("\\begin{itemize}\n\item ")
  microphone_actor_list = []
  for this_log_entry in this_microphone_log:
    the_actor = this_log_entry [0]
    if (the_actor not in microphone_actor_list):
      microphone_actor_list.append (the_actor)
  first_actor = 1
  for this_actor in actors_by_entrance:
    actor_pages = []
    if (this_actor in microphone_actor_list):
      for this_log_entry in this_microphone_log:
        if (this_actor == this_log_entry [0]):
          actor_pages.append(this_log_entry[1])
      if (first_actor == 0):
        listfile.write (";\n\\item ")
      else:
        first_actor = 0
      if (do_trace == 1):
        pprint.pprint (this_actor, tracefile)
        pprint.pprint (actor_pages, tracefile)
      listfile.write (quote_for_tex(actor_expanded_name(this_actor)))
      listfile.write (" on pages " + reformat_page_range(actor_pages))
  listfile.write (".\end{itemize}\n" + "\\\\\\hline" + "\n")
listfile.close()

# Output a label for each microphone showing who uses it.

listfile = open (os.path.join (output_directory, output_root) +
                 ".microphone_labels.tex", "wt")
for the_microphone in range (1, max_microphone+1):
  this_microphone_log = microphone_log [the_microphone]
  if (len(this_microphone_log) == 0):
    continue
  listfile.write ("\\parbox[t]{4.75in}{" + 
    str(the_microphone) + "\\hfil\\break ")
  microphone_actor_list = []
  for this_log_entry in this_microphone_log:
    the_actor = this_log_entry [0]
    if (the_actor not in microphone_actor_list):
      microphone_actor_list.append (the_actor)
  first_actor = 1
  for this_actor in actors:
    if (this_actor in microphone_actor_list):
      if (first_actor == 0):
        listfile.write ("\\hfil\\break ")
      else:
        first_actor = 0
      listfile.write (quote_for_tex(this_actor ["name"]))
  listfile.write ("}\\hfil\\break\\vskip 0.25in" + "\n")
listfile.close()

# Output a label for each microphone channel controlled by the
# microphone operator

listfile = open (os.path.join (output_directory, output_root) +
                 ".microphone_channels.tex", "wt")
for the_microphone in range (1, max_microphone+1):
  this_microphone_log = microphone_log [the_microphone]
  if (len(this_microphone_log) == 0):
    continue
  listfile.write ("\\vskip 0.25in \\vbox to0.75in {\\parbox[t]{1in}{")
  microphone_actor_list = []
  for this_log_entry in this_microphone_log:
    the_actor = this_log_entry [0]
    if (the_actor not in microphone_actor_list):
      microphone_actor_list.append (the_actor)
  first_actor = 1
  for this_actor in actors:
    if (this_actor in microphone_actor_list):
      the_rolls = rolls [this_actor ["name"]]
      roll_names = ""
      for the_character in the_rolls:
        if (len(roll_names) == 0):
          roll_names = the_character ["name"]
      listfile.write (quote_for_tex(roll_names))
      break
  listfile.write ("\\vfil}}" + "\n")
listfile.close()

# Convert the page log into a microphone move dictionary keyed by
# page number and containing [microphone, to actor, from actor,
# from page].  
microphone_moves = {}

if (do_trace == 1):
  tracefile.write ("Page log:" + "\n")
  pprint.pprint (page_log, tracefile)
  tracefile.write ("\n")

for the_actor in actors:
  the_actor ["microphone"] = 0
  the_actor ["new_microphone"] = 0
  the_actor ["on_stage"] = 0
  the_actor ["left_stage"] = 0
  the_actor ["group"] = ""
  
# Previous microphone holder is a dictionary keyed by microphone
# number which holds the actor previously holding that
# microphone. 
previous_microphone_holder = {}

# First microphone holder remembers which actor first wears
# each microphone, so it can be given to him before the start
# of the show.
first_microphone_holder = {}

# Last microphone holder remembers which actor last
# wears each microphone, so it can be taken from him
# at the end of the show.
last_microphone_holder = {}

# Intermission microphone holder remembers which actor
# wears each microphone after the intermission, so we can start
# a rehearsal with the intermission.
intermission_microphone_holder = {}

for the_microphone in range (1,max_microphone+1):
  previous_microphone_holder [the_microphone] = ""
  first_microphone_holder [the_microphone] = ""
  last_microphone_holder [the_microphone] = ""
  intermission_microphone_holder [the_microphone] = ""

prev_page = 0
intermission_page = 0

for the_page in page_list:
  if ("intermission" in pages[the_page]):
    intermission_page = the_page
  if (the_page in page_log):
    this_page_log = page_log [the_page]
    for the_actor in actors:
      the_actor ["new_microphone"] = 0
    for this_log_entry in this_page_log:
      the_actor, the_microphone, group = this_log_entry 
      the_actor ["new_microphone"] = the_microphone
    for the_actor in actors:
      the_microphone = the_actor ["new_microphone"]
      if (the_microphone == 0):
        if (the_actor ["on_stage"] == 1):
# this actor is leaving the stage.  Record the page in case another actor
# uses this microphone later.
          the_actor ["on_stage"] = 0
          the_actor ["left_stage"] = prev_page
          old_microphone = the_actor ["microphone"]
          previous_microphone_holder [old_microphone] = the_actor
          if (do_trace):
            tracefile.write ("Microphone_moves 1: " + the_page + " " +
                             str(the_microphone) + " " + 
                             the_actor ["name"] + " " +
                             str(old_microphone) + "\n")
      else:
        if (first_microphone_holder[the_microphone] == ""):
          first_microphone_holder[the_microphone] = the_actor
        last_microphone_holder[the_microphone] = the_actor
        if (intermission_page != 0):
          if (intermission_microphone_holder [the_microphone] == ""):
            intermission_microphone_holder [the_microphone] = the_actor
        if (the_actor ["on_stage"] == 0):
          if (do_trace):
            tracefile.write ("Microphone_moves 2: " + the_page + " " +
                             str(the_microphone) + " " + 
                             the_actor ["name"] + "\n")
          the_actor ["microphone"] = the_microphone
          the_actor ["on_stage"] = 1
          if (previous_microphone_holder [the_microphone] != ""):
            previous_actor = previous_microphone_holder [the_microphone]
            if (previous_actor != the_actor):
              if (do_trace == 1):
                tracefile.write ("Microphone_moves 3: " + the_page + " " +
                                 str(the_microphone) + " " + 
                                 the_actor ["name"] + " " +
                                 previous_actor ["name"] + "\n")
              if (the_page not in microphone_moves):
                microphone_moves [the_page] = []
              move_record = [the_microphone, the_actor,
                             previous_actor,
                             previous_actor ["left_stage"]]
              microphone_moves [the_page].append(move_record)
  prev_page = the_page

if (do_trace):
  tracefile.write ("Microphone moves before moving to intermission:" + "\n")
  pprint.pprint (microphone_moves, tracefile)
  tracefile.write ("\n")
  tracefile.write ("Previous microphone holders:" + "\n")
  pprint.pprint (previous_microphone_holder, tracefile)
  tracefile.write ("\n")

# Modify the moves to bring them to an intermission whenever
# possible.
changes_made = 1
while (changes_made == 1):
  changes_made = 0
  for the_page in page_list:
    if ("intermission" in pages[the_page]):
      continue
    if (the_page in microphone_moves):
      for move_record in microphone_moves[the_page]:
        the_microphone, the_actor, previous_actor, previous_page = move_record
        intermission_page = ""
        for a_page in page_list:
          if ((a_page >= previous_page) and
              (a_page <= the_page) and
              ("intermission" in pages[a_page])):
            intermission_page = a_page
            break
        if (intermission_page != ""):
          if (do_trace):
            tracefile.write ("Moving " + str(move_record) +
                             " from page " + the_page + 
                             " to page " +
                             intermission_page + "\n")
          microphone_moves[the_page].remove(move_record)
          if (intermission_page not in microphone_moves):
            microphone_moves [intermission_page] = []
          microphone_moves[intermission_page].append(move_record)
          changes_made = 1
    
if (do_trace):
  tracefile.write ("microphone moves after moving to intermission:" + "\n")
  pprint.pprint (microphone_moves, tracefile)
  tracefile.write ("\n")

listfile = open (os.path.join (output_directory, output_root) +
                 ".microphone_moves.tex", "wt")
for the_page in page_list:
  if (the_page in microphone_moves):
    first_actor = 1
    for this_actor in actors:
      for move_record in microphone_moves[the_page]:
        the_microphone, the_actor, previous_actor, previous_page = move_record
        if (the_actor == this_actor):
          if (first_actor == 0):
            listfile.write (";\n\\item ")
          else:
            listfile.write (format_pageno(the_page) + "&")
            intermission_page = 0
            if ("intermission" in pages[the_page]):
              listfile.write ("Intermission: ")
              intermission_page = 1
            first_actor = 0
            listfile.write ("\\begin{itemize}\n\item ")
          listfile.write (quote_for_tex(actor_expanded_name (the_actor)))
          listfile.write (" gets microphone " + str(the_microphone))
          listfile.write (" from " +
                          quote_for_tex(actor_expanded_name (previous_actor)))
          if (intermission_page == 0):
            listfile.write (" after page " + format_pageno(previous_page))
    if (first_actor == 0):
      listfile.write ("." + "\n" + "\\end{itemize}" + "\\\\\\hline" + "\n")

# Assuming the stage manager will be handling all microphone moves,
# compile a list of all microphone operations for him.
# The microphone_transactions dictionary is keyed by page number.
# Each value is a list: microphone number, 0 or 1 meaning from
# or to, and the actor.
microphone_transactions = {}

for the_page in page_list:
  if (the_page in microphone_moves):
    for move_record in microphone_moves[the_page]:
      the_microphone, the_actor, previous_actor, previous_page = move_record
      microphone_transaction_1 = [the_microphone, 0, previous_actor]
      if (previous_page not in microphone_transactions):
        microphone_transactions [previous_page] = []
      microphone_transactions[previous_page].append(microphone_transaction_1)
      microphone_transaction_2 = [the_microphone, 1, the_actor]
      if (the_page not in microphone_transactions):
        microphone_transactions [the_page] = []
      microphone_transactions[the_page].append(microphone_transaction_2)

if (do_trace == 1):
  tracefile.write ("Microphone transactions:" + "\n")
  pprint.pprint (microphone_transactions, tracefile)
  tracefile.write ("\n")

listfile = open (os.path.join (output_directory, output_root) +
                 ".stage_manager_before_show.tex", "wt")
for the_microphone in range (1, max_microphone+1):
  if (first_microphone_holder[the_microphone] != ""):
    the_actor = first_microphone_holder [the_microphone]
    listfile.write (str(the_microphone) + "&" +
                    quote_for_tex(actor_expanded_name (the_actor)) + 
                    "\\\\\\hline" + "\n")
listfile.close()

listfile = open (os.path.join (output_directory, output_root) +
                 ".stage_manager_during_show.tex", "wt")
for the_page in page_list:
  if (the_page in microphone_transactions):
    transactions_list = microphone_transactions[the_page]
    transactions_list.sort()
    transactions_list_length = len(transactions_list)
    target_line = int((transactions_list_length+1)/2)
    if (target_line < 1):
      target_line = 1
    if (target_line > transactions_list_length):
      target_line = transaction_list_length
    line_number = 1
    for transaction_record in transactions_list:
      the_microphone, transaction_type, the_actor = transaction_record
      direction_list = ["from", "to"]
      if (line_number == target_line):
        pageno_text = format_pageno(the_page)
      else:
        pageno_text = " "
      if (line_number < transactions_list_length):
        endofline_text = "\\\\*\\cline{2-4}"
      else:
        endofline_text = "\\\\\\hline\\hline"
      listfile.write (pageno_text + "&" +
                      str(the_microphone) + "&" +
                      direction_list[transaction_type] + "&" +
                      quote_for_tex(actor_expanded_name (the_actor)) +
                      endofline_text + "\n")
      line_number = line_number + 1
listfile.close()

listfile = open (os.path.join (output_directory, output_root) +
                 ".stage_manager_after_show.tex", "wt")
for the_microphone in range (1, max_microphone+1):
  if (last_microphone_holder[the_microphone] != ""):
    the_actor = last_microphone_holder [the_microphone]
    listfile.write (str(the_microphone) + "&" +
                    quote_for_tex(actor_expanded_name (the_actor)) + 
                    "\\\\\\hline" + "\n")
listfile.close()

listfile = open (os.path.join (output_directory, output_root) +
                 ".stage_manager_at_intermission.tex", "wt")
for the_microphone in range (1, max_microphone+1):
  if (intermission_microphone_holder [the_microphone] != ""):
    the_actor = intermission_microphone_holder [the_microphone]
    listfile.write (str(the_microphone) + "&" +
                    quote_for_tex(actor_expanded_name (the_actor)) +
                    "\\\\\\hline" + "\n")
listfile.close()

def format_page_range (low_page, high_page):
  for this_page in page_list:
    if ((this_page >= low_page) and
        (this_page <= high_page) and
        ("intermission" in pages[this_page])):
      return ("during intermission (page " + format_pageno(this_page) + ")")
  if ((low_page in song_before_page) and
      (high_page in song_after_page)):
    return ("after " +
            quote_for_tex (song_before_page [low_page]) +
            " (page " + format_pageno(low_page) + ")" + 
            " but before " +
            quote_for_tex (song_after_page [high_page]) +
            " (page " + format_pageno(high_page) + ")")
  return ("between pages " +
          format_pageno(low_page) +
          " and " +
          format_pageno(high_page))

# Assuming the actors will be handling microphone moves during
# the show, output a list for each actor showing who he gets
# his microphone from and who he gives it to, and when.

listfile = open (os.path.join (output_directory, output_root) +
                 ".actors.tex", "wt")
for the_actor in actors:
# Summarize microphone use
  actor_log = the_actor ["log"]
  actor_microphone_set = set ()
  for [pageno, the_microphone, group] in actor_log:
    if (the_microphone not in actor_microphone_set):
      actor_microphone_set.add (the_microphone)
  used_by_other = 0
  for other_actor in actors:
    if (other_actor != the_actor):
      other_actor_log = other_actor ["log"]
      for [pageno, the_microphone, group] in other_actor_log:
        if (the_microphone in actor_microphone_set):
          used_by_other = 1
          break
      if (used_by_other == 1):
        break
  if (len(actor_microphone_set) == 0):
    continue
  listfile.write (
    "\\vbox {\\setlength{\parindent}{0.25in}\\noindent " + 
    "\\textbf{" + quote_for_tex(actor_expanded_name(the_actor)) +
    "}: ")
  listfile.write ("You will use ")
  if (len(actor_microphone_set) == 1):
    listfile.write ("microphone ")
  else:
    listfile.write ("microphones ")
  microphone_count = 1
  for the_microphone in range (1, max_microphone+1):
    if (the_microphone in actor_microphone_set):
      if (microphone_count != 1):
        if (microphone_count == len(actor_microphone_set)):
          listfile.write (" and ")
        else:
          listfile.write (", ")
      listfile.write (str(the_microphone))
      microphone_count = microphone_count + 1
  if (used_by_other == 0):
    listfile.write (" throughout the show. \\par")
  else:
    listfile.write (".  \\par" + "\n")
# Go through all the entries in the log
  entry_number = 1
  for [this_page, this_microphone, group] in actor_log:
# Find the immediately previous and next use of this microphone.
    prev_page = ""
    prev_actor = ""
    next_page = ""
    next_actor = ""
    for other_actor in actors:
      other_actor_log = other_actor ["log"]
      for [other_page, other_microphone, other_group] in other_actor_log:
        if (other_microphone == this_microphone):
          if ((prev_page == "") and (other_page < this_page)):
            prev_page = other_page
            prev_actor = other_actor
          if ((prev_page < other_page) and (other_page < this_page)):
            prev_page = other_page
            prev_actor = other_actor
          if ((next_page == "") and (other_page > this_page)):
            next_page = other_page
            next_actor = other_actor
          if ((next_page > other_page) and (other_page > this_page)):
            next_page = other_page
            next_actor = other_actor
#
# If there is no previous use, this actor gets the microphone at the top of
# the show.
    if (prev_page == ""):
      listfile.write (str(entry_number) +
                      ". \\parbox[t]{7in}{Get microphone " +
                      str(this_microphone) + 
                      " from the stage manager before the show starts.}\\par" +
                      "\n")
      entry_number = entry_number + 1
    else:
      if (the_actor != prev_actor):
        listfile.write (str(entry_number) +
                        ".  \\parbox[t]{7in}{Get microphone " + 
                        str(this_microphone) +
                        " from " + 
                        quote_for_tex(actor_expanded_name(prev_actor)) +
                        " " +
                        format_page_range(prev_page, this_page) +
                        ".}\\par" + "\n")
        entry_number = entry_number + 1
# If there is no subsequent use, he keeps it until the end of the show.
    if (next_page == ""):
      listfile.write (str(entry_number) +
                      ".  \\parbox[t]{7in}{Return microphone " +
                      str(this_microphone) + 
                      " to the stage manager at the end of the show.}\\par" +
                      "\n")
      entry_number = entry_number + 1
    else:
      if (the_actor != next_actor):
        listfile.write (str(entry_number) +
                        ".  \\parbox[t]{7in}{Give microphone " + 
                        str(this_microphone) +
                        " to " + 
                        quote_for_tex(actor_expanded_name (next_actor)) +
                        " " +
                        format_page_range (this_page, next_page) +
                        ".}\\par" + "\n")
        entry_number = entry_number + 1
  listfile.write ("\\vskip 0.25in}\\par " + "\n" + "\n")
listfile.close()

#
# Suppress switching off a microphone if it will be switched back
# on soon.
#
prev_microphone_list = []
for this_page in page_list:
  this_page_activities_list = activities [this_page]
  for activity in this_page_activities_list:
    if (activity["type"] == "start_time"):
      this_page_start_time = activity ["value"]
    if (activity["type"] == "duration"):
      this_page_duration = activity["value"]
  if (this_page in microphone_switching_log):
    microphone_list = microphone_switching_log [this_page]
  else:
    microphone_list = []
  for this_microphone in prev_microphone_list:
    if (this_microphone not in microphone_list):
      for other_page in page_list:
        if (other_page <= this_page):
          continue
        if (other_page not in microphone_switching_log):
          continue
        other_microphone_list = microphone_switching_log [other_page]
        if (this_microphone not in other_microphone_list):
          continue
        other_page_activities_list = activities [other_page]
        for activity in other_page_activities_list:
          if (activity ["type"] == "start_time"):
            other_page_start_time = activity ["value"]
          if (activity ["type"] == "duration"):
            other_page_duration = activity ["value"]
        microphone_off_time = (other_page_start_time - 
          (this_page_start_time + this_page_duration))
        if (microphone_off_time < min_microphone_off_time):
          if (do_trace):
            tracefile.write (
              "Do not switch off microphone " +
              str(this_microphone) + 
              " on page " + this_page + "\n")
          microphone_list.append (this_microphone)
          microphone_switching_log [this_page] = microphone_list
          break
  prev_microphone_list = microphone_list

# Write a file for X32 Theatre Control.  This is a text file which
# can be converted to an sqlite3 file using sqlite3.  The resulting
# sqlite3 file can be read by X32 Theatre Control.
#
# The sqlite3 database contains the following tables:
#   config:       columns param and value contain configuration keywords
#                 and their values.  See below for valid keywords and values.
#   cues:         The first two columns are number and point, both integers.
#                 They are combined into a unique integer called cueid.
#                 The third column is the cue's name.  An apostrophe in the
#                 cue name is represented as two apostrophes since the text
#                 field is delimited by apostrophes.
#                 The next eight columns are dca01Channels through
#                 dca08Channels.  Each is a list of profile IDs
#                 to place in the DCA on this cue.
#                 The next eight columns are dca01Label through dcl08Label.
#                 These labels are placed on the DCA's scribble strip.
#                 Null means no label.
#                 The next three columns are channelPositions, channelProfiles
#                 and fxMutes.  ChannelPositions is a list of channel number
#                 = position id.
#                 Optional columns are channelFX and snippets.
#                 Snippets is the id of the snippet to invoke on this cue.
#   positions:    Columns are an integer id, name, shortName, numeric delay
#                 and numeric pan.  There is one record for each stage
#                 position, each with a value for delay and pan.
#                 By default there is one position with id 0 at center stage.
#                 which is center stage.
#   profiles:     Columns are an integer id, channel, name, integer default,
#                 and data.  There is one profile for each (character,
#                 microphone) combination.  Characters that are on stage at
#                 the same time and played by a single actor are combined
#                 into a single profile.
#                 Data can be blank or an X32 string to set up the X32 channel.
#   ensembles:    Columns are an integer id, name and channels.  There is a
#                 record for each group of microphones.  Channels is a list
#                 of profile IDs.
#   snippetCache: Columns are integer snippet and name.  There are 100
#                 snippets numbered 0 through 99.  Unused snippets have
#                 name NULL.
#   fxCache:      Columns are integer fx and name.  Records start with
#                 fx number 1.
#
# The config keywords are as follows:
#   venue:        The name of the theatre
#   dcas:           A list of the DCAs to be controlled,
#                   typically '1,2,3,4,5,6,7,8'
#   channels:       A list of the input channels to be controlled,
#                   typically all but the backup channels.
#   buttonMap:      A list of number=number, typically '1=11,0=12'.
#   consoleModel:   empty string
#   consoleVersion: empty string
#   consoleIP:      empty string
#   consoleMAC:     empty string
#   autoConnect:    '0'
#   backupChannels: A list of backup channel=primary channel.
#   enableChannelMonitoring: '0'
#   gangLR:         '0'
#   gangLRChannels:  empty string
#   gangLRName:      empty string
#   gangLRcolour:    empty string
#   designer:        Name of the designer
#   fxAssigns:       A list of integers.
#   fxMutes:         empty string
#   defaultFX:       '1'
#   snippetRecall:   '1'
#   fxBusMap:        '1=13,2=14,3=15,4=16'

listfile = open (os.path.join (output_directory, output_root) +
                 ".X32TC.txt", "wt")
listfile.write ("PRAGMA foreign_keys=OFF;\n")
listfile.write ("BEGIN TRANSACTION;\n")
listfile.write ("CREATE TABLE 'config' ('param' TEXT, 'value' TEXT, ")
listfile.write ("PRIMARY KEY(param));\n")
listfile.write ("INSERT INTO config VALUES ('venue', '" + venue_name + "');\n")
listfile.write ("INSERT INTO config VALUES ('dcas', '1,2,3,4,5,6,7,8');\n")
listfile.write ("INSERT INTO config VALUES ('channels', '")
first_microphone=1
for the_microphone in range (1,max_microphone+1):
  this_microphone_log = microphone_log [the_microphone]
  if (len(this_microphone_log) == 0):
    continue
  if (first_microphone == 0):
    listfile.write (",")
  listfile.write (str(the_microphone))
  first_microphone=0
listfile.write ("');\n")
listfile.write ("INSERT INTO config VALUES ('buttonMap', '1=11,0=12');\n")
listfile.write ("INSERT INTO config VALUES ('consoleModel', '');\n")
listfile.write ("INSERT INTO config VALUES ('consoleVersion', '');\n")
listfile.write ("INSERT INTO config VALUES ('consoleIP', '');\n")
listfile.write ("INSERT INTO config VALUES ('consoleMAC', '');\n")
listfile.write ("INSERT INTO config VALUES ('autoConnect', '0');\n")
listfile.write ("INSERT INTO config VALUES ('backupChannels', '');\n")
listfile.write ("INSERT INTO config VALUES ('enableChannelMonitoring', '');\n")
listfile.write ("INSERT INTO config VALUES ('gangLR', '0');\n")
listfile.write ("INSERT INTO config VALUES ('gangLRChannels', '0');\n")
listfile.write ("INSERT INTO config VALUES ('gangLRName', '');\n")
listfile.write ("INSERT INTO config VALUES ('gangLRColour', '');\n")
listfile.write ("INSERT INTO config VALUES ('designer', '" +
                designer_name + "');\n")
listfile.write ("INSERT INTO config VALUES ('fxAssigns', '0');\n")
listfile.write ("INSERT INTO config VALUES ('fxMutes', '');\n")
listfile.write ("INSERT INTO config VALUES ('defaultFX', '');\n")
listfile.write ("INSERT INTO config VALUES ('snippetRecall', '');\n")
listfile.write ("INSERT INTO config VALUES ('fxBusMap', '');\n")

listfile.write ("CREATE TABLE 'cues' (" +
                "'number' INTEGER NOT NULL DEFAULT 999, " +
                "'point' INTEGER NOT NULL DEFAULT 0, " +
                "'name' TEXT, " +
                "'dca01Channels' TEXT, 'dca02Channels' TEXT, " +
                "'dca03Channels' TEXT, 'dca04Channels' TEXT, " +
                "'dca05Channels' TEXT, 'dca06Channels' TEXT, " +
                "'dca07Channels' TEXT, 'dca08Channels' TEXT, " +
                "'dca01Label' TEXT, 'dca02Label' TEXT, " +
                "'dca03Label' TEXT, 'dca04Label' TEXT, " +
                "'dca05Label' TEXT, 'dca06Label' TEXT, " +
                "'dca07Label' TEXT, 'dca08Label' TEXT, " +
                "'ChannelPositions' TEXT, " +
                "'ChannelProfiles' TEXT, " +
                "'fxMutes' TEXT, " +
                "'channelFX' TEXT, " +
                "'snippets' TEXT);\n")

# Profile_list is a list of profiles
profile_list = list()

# Each profile is a dictionary with elements name, microphone,
# group and and based_on.  Based_on is a list of lists.  Each list contains
# a character name, a page, the microphone number and the group name.
# The character name may be a composite if an actor plays more than
# one character at a time.
#
# If a character changes microphones we will need a profile for each microphone.
profile_list_additional = list()

if (do_trace == 1):
  tracefile.write ("Character_log (length " + str(len(character_log)) + "):\n")
  pprint.pprint (character_log, tracefile)
  
for the_page, the_microphone in character_log:
  character_record = character_log [the_page, the_microphone]
  profile_name = character_record[0]
  the_group = character_record[2]
  character_list = character_record[3]
  profile_found = 0
  for profile in profile_list:
    if (profile["name"] == profile_name):
      profile_found = 1;
      break
  if (profile_found == 0):
    profile = dict()
    profile["name"] = profile_name
    profile["group"] = the_group
    profile["microphone"] = the_microphone
    profile["based_on"] = [[profile_name, the_page, the_microphone,
                            the_group, character_list]]
    profile_list.append(profile)
    continue
  
  if (profile["microphone"] == the_microphone):
    # This is a continuation of a character's presence on stage
    profile["based_on"] = profile["based_on"] + [[profile_name,
                                                  the_page,
                                                  the_microphone,
                                                  the_group,
                                                  character_list]]
    continue
  # The character is using a different microphone
  # We need a different profile.
  need_new_profile = 1
  for profile_additional in profile_list_additional:
    if ((profile_additional["name"] == profile["name"]) and
        (profile_additional["microphone"] == the_microphone)):
      # We already have the additional profile.
      profile_additional["based_on"] = profile_additional["based_on"] \
        + [[profile_name, the_page, the_microphone,
            the_group, character_list]]
      need_new_profile = 0
      break
  if (need_new_profile == 1):
    profile_additional = dict()
    profile_additional["name"] = profile_name
    profile_additional["microphone"] = the_microphone
    profile_additional["group"] = the_group
    profile_additional["based_on"] = [[profile_name, the_page,
                                       the_microphone,
                                       the_group,
                                       character_list]]
    profile_list_additional.append(profile_additional)

if (do_trace == 1):
  tracefile.write ("Profile_list 1 (length " + str(len(profile_list)) + "):\n")
  pprint.pprint (profile_list, tracefile)
  tracefile.write ("Profile_list_additonal:\n")
  pprint.pprint (profile_list_additional, tracefile)
        
# Give the additional profiles unique names so we can merge them into the
# profile list.

for profile in profile_list_additional:
  based_on_list = profile["based_on"]
  first_based_on = based_on_list[0]
  the_page = first_based_on[1]
  profile["name"] = profile["name"] + " page " + format_pageno(the_page)

profile_list = profile_list + profile_list_additional

if (do_trace == 1):
  tracefile.write ("Profile_list 2 (length " + str(len(profile_list)) + "):\n")
  pprint.pprint (profile_list, tracefile)

# Now shrink the list by combining profiles that differ only in the
# pages they are on and the group they are in.

done = 0
while (done == 0):
  deleted = 0
  profile_length = len(profile_list)
  for id1 in range (0,profile_length-1):
    for id2 in range (id1+1,profile_length):
      if (do_trace == 1):
        tracefile.write ("processing profiles " +
                         str(id1) + " and " + str(id2) +
                         " of " + str(profile_length) + ".\n")
      profile_1 = profile_list [id1]
      profile_2 = profile_list [id2]
      if ((profile_1["name"] == profile_2["name"]) and
          (profile_1["microphone"] == profile_2["microphone"])):
        profile_1["based_on"] = profile_1["based_on"] + profile_2["based_on"]
        if (do_trace == 1):
          tracefile.write ("deleting profile " + str(id2) + ".\n")
          pprint.pprint (profile_list[id2], tracefile)
        del profile_list[id2]
        deleted = 1
        break
    if (deleted == 1):
      break
  if (deleted == 0):
    done = 1

if (do_trace == 1):
  tracefile.write ("Profile_list 3 (length " + str(len(profile_list)) + "):\n")
  pprint.pprint (profile_list, tracefile)
  
# Order profiles by the declaration of their underlying character(s).
new_profile_list = list()
for character_name in characters:
  if (do_trace == 1):
    tracefile.write ("Sorting character " + character_name + ".\n")
  for profile in profile_list:
    if (profile not in new_profile_list):
      based_on_list = profile["based_on"]
      first_based_on = based_on_list[0]
      the_profile_name, the_page, the_microphone, the_group, character_list = \
        first_based_on
      the_character_name = character_list[0]
      if (do_trace == 1):
        tracefile.write ("Sorting profile " + profile["name"] +
                         " for character " + character_name +
                         " based on " + the_character_name + ".\n")
        pprint.pprint (based_on_list, tracefile)
      if (the_character_name == character_name):
        new_profile_list.append(profile)
profile_list = new_profile_list

if (do_trace == 1):
  tracefile.write ("Profile_list 4 (length " + str(len(profile_list)) + "):\n")
  pprint.pprint (profile_list, tracefile)

# Give each profile an ID
for ID, profile in enumerate(profile_list):
  profile["ID"] = ID+1
  
if (do_trace == 1):
  tracefile.write ("profile_list 5:\n")
  pprint.pprint (profile_list, tracefile)

# The channel numbers in the cues are actually profile IDs.
# Create a mapping between microphone numbers and page to
# profile IDs.
find_profile = dict()

for profile in profile_list:
  based_on_list = profile["based_on"]
  if (do_trace == 1):
    tracefile.write ("Based on list: ")
    pprint.pprint (based_on_list, tracefile)
  for based_on in based_on_list:
    if (do_trace == 1):
      tracefile.write ("Based on: ")
      pprint.pprint (based_on, tracefile)
    character_name = based_on[0]
    the_page = based_on[1]
    the_microphone = based_on[2]
    group_name = based_on[3]
    find_profile[the_page, the_microphone] = (profile["ID"], group_name)

if (do_trace == 1):
  tracefile.write ("Find_profile:\n")
  pprint.pprint (find_profile, tracefile)

if (do_trace == 1):
  tracefile.write ("Groups 1:\n")
  pprint.pprint (groups, tracefile)
  
# In nosolo style, we also have a group for each profile.
if (DCA_style == "nosolo"):
  for profile in profile_list:
    profile_name = profile["name"]
    matching_group_found = 0
    for group_name in groups:
      if (group_name == profile_name):
        matching_group_found = 1
    if (matching_group_found == 0):
      if (do_trace == 1):
        tracefile.write ("Creating a group for profile " + profile_name + ".\n")
      group_dict = dict()
      group_dict["number"] = group_number
      group_dict["name"] = profile_name
      group_number = group_number + 1
      based_on_list = profile["based_on"]
      if (do_trace == 1):
        tracefile.write ("Based on list: ")
        pprint.pprint (based_on_list, tracefile)
      for based_on in based_on_list:
        if (do_trace == 1):
          tracefile.write ("Based on: ")
          pprint.pprint (based_on, tracefile)
        based_on_profile_name = based_on[0]
        the_page = based_on[1]
        the_microphone = based_on[2]
        group_name = based_on[3]
        based_on_characters = based_on[4]
        for character_name in based_on_characters:
          character_dict = characters[character_name]
          if ("preferred_DCA" in character_dict):
            if ("preferred_DCA" in profile):
              if (character_dict["preferred_DCA"] != profile["preferred_DCA"]):
                print ("Profile " + profile_name + " is based on characters " +
                       " with conflicting preferred_DCA.")
                error_counter = error_counter + 1
            profile["preferred_DCA"] = character_dict ["preferred_DCA"]
            if (do_trace == 1):
              tracefile.write ("Profile " + profile_name +
                               " gets preferred DCA from character " +
                               character_name + ".\n")
            group_dict["preferred_DCA"] = character_dict ["preferred_DCA"]
      groups[profile_name] = group_dict
      if (do_trace == 1):
        tracefile.write ("Adding group " + profile_name + ".\n")

if (do_trace == 1):
  tracefile.write ("Groups 2:\n")
  pprint.pprint (groups, tracefile)
  
# Groups is a dictionary indexed by group name.
# Augment each group by noting which profiles
# are speaking on each page, within that group.
for this_page in page_list:
  for the_microphone in range(1,max_microphone+1):
    if (this_page, the_microphone) in find_profile:
      profile_ID, group_name = find_profile[this_page, the_microphone]
      if (group_name == "" and DCA_style == "nosolo"):
        for the_profile in profile_list:
          if (the_profile["ID"] == profile_ID):
            group_name = the_profile["name"]
      group_dict = groups[group_name]
      group_dict["name"] = group_name
      the_profiles = list()
      if ("pages" not in group_dict):
        group_dict["pages"] = dict()
      group_page = group_dict["pages"]
      if (this_page in group_page):
        the_profiles = group_page[this_page]
      if (profile_ID not in the_profiles):
        group_page[this_page] = the_profiles + [profile_ID]

if (do_trace == 1):
  tracefile.write ("Groups 3:\n")
  pprint.pprint (groups, tracefile)

# DCAs is a dictionary indexed by DCA number.  Each entry is a
# DCA, which is a dictionary indexed by page number.  Each such entry
# is a dictionary with entries for the name of the DCA on that page
# and the list of profiles to include in that DCA.

DCAs = dict()
if (DCA_count_specified == 0):
  DCA_count = 8
  
for DCA_number in range (0,DCA_count):
  this_DCA = dict()
  this_DCA["number"] = DCA_number
  this_DCA["pages"] = dict()
  DCAs[DCA_number] = this_DCA

if (do_trace == 1):
  tracefile.write ("DCAs 1:\n")
  pprint.pprint (DCAs, tracefile)  

# Find a good DCA for this group on this page.  In solo style, the blank
# group goes in DCA 0, named Solo.  Nothing else goes there.
# Otherwise, prefer the previously used DCA, if it isn't being used.
# If it is, find the least-occupied unused DCA.  If there is no DCA
# that is unused for this page, share the one that is least used.
# If a group prefers a particular DCA, use it if it is available,
# and even if it is not, if no DCA is unused.

def find_good_DCA (this_group, this_page):
  if (do_trace == 1):
    tracefile.write ("Finding a good DCA for group " + this_group["name"] +
                     ":\n")
    pprint.pprint (this_group, tracefile)
    tracefile.write ("and page:\n")
    pprint.pprint (this_page, tracefile)
  old_DCA_number = -1
  if ("old_DCA_number" in this_group):
    old_DCA_number = this_group["old_DCA_number"]
    this_DCA = DCAs[old_DCA_number]
    DCA_pages = this_DCA["pages"]
    if (this_page not in DCA_pages):
      # The previously-used DCA has this page empty.  Use it.
      return (this_DCA)
  if ("preferred_DCA" in this_group):
    preferred_DCA = this_group["preferred_DCA"]
    this_DCA = DCAs[preferred_DCA]
    DCA_pages = this_DCA["pages"]
    if (this_page not in DCA_pages):
      # The preferred DCA has this page empty.  Use it.
      return (this_DCA)
  # We must choose a DCA.  Of the DCAs with this page unused, pick the one
  # that has the least pages used, thus spreading the profiles among the
  # DCAs.
  best_DCA_size = -1
  DCA_found = 0
  for DCA_number in DCAs:
    this_DCA = DCAs[DCA_number]
    if (DCA_style == "solo" and DCA_number == 0):
      if (this_group["name"] == ""):
        # Use the solo DCA.
        return (this_DCA)
      else:
        continue
    DCA_pages = this_DCA["pages"]
    DCA_size = len(this_DCA["pages"])
    if (this_page not in DCA_pages):
      if ((DCA_size < best_DCA_size) or (best_DCA_size == -1)):
        best_DCA_size = DCA_size
        best_DCA = this_DCA
        DCA_found = 1
  if (DCA_found == 1):
    return (best_DCA)
  # No DCA was found with this page unused.  We must share.  Use the
  # preferred DCA if one is specified, otherwise the last DCA used.
  # If there is no last DCA, choose the one that has the least pages
  # used.
  if (do_trace == 1):
    tracefile.write ("We must share a DCA.\n")
  if ("preferred_DCA" in this_group):
    preferred_DCA = this_group["preferred_DCA"]
    this_DCA = DCAs[preferred_DCA]
    # Since all DCAs are occupied, use the preferred DCA.
    return (this_DCA)
  if (old_DCA_number != -1):
    this_DCA = DCAs[old_DCA_number]
    return (this_DCA)
  best_DCA_size = -1
  DCA_found = 0
  for DCA_number in DCAs:
    this_DCA = DCAs[DCA_number]
    DCA_pages = this_DCA["pages"]
    DCA_size = len(this_DCA["pages"])
    if ((DCA_size < best_DCA_size) or (best_DCA_size == -1)):
      if (do_trace == 1):
        tracefile.write ("Nominating DCA " + str(DCA_number) + ".\n")
      best_DCA_size = DCA_size
      best_DCA = this_DCA
      DCA_found = 1
  if (DCA_found == 1):
    return (best_DCA)
  if (do_trace == 1):
    tracefile.write ("No good DCA found.\n")
    for DCA_number in DCAs:
      tracefile.write ("DCA number " + str(DCA_number) + ":\n")
      pprint.pprint (DCAs[DCA_number], tracefile)
  return None

# Assign groups to DCAs.  The groups are processed in the order
# they were encountered.  In nosolo mode, this processes the characters
# after the groups, in the order they were listed.  To try to get
# characters and groups into their preferred DCAs, we assign groups
# with preferred DCAs before those without.

group_list = dict()
for group_name in groups:
  group_dict = groups[group_name]
  group_number = group_dict["number"]
  group_list[group_number] = group_dict

if (do_trace == 1):
  tracefile.write ("Group list:\n")
  pprint.pprint (group_list, tracefile)

def assign_DCA (group_number):
  this_group = group_list[group_number]
  group_name = this_group["name"]
  for this_page in page_list:
    if ("pages" not in this_group):
      continue
    group_page = this_group["pages"]
    if (this_page in group_page):
      the_profiles = group_page[this_page]
      this_DCA = find_good_DCA (this_group, this_page)
      if (do_trace == 1):
        tracefile.write ("found DCA:\n")
        pprint.pprint (this_DCA, tracefile)
      this_group["old_DCA_number"] = this_DCA["number"]
      DCA_pages = this_DCA ["pages"]
      if (this_page not in DCA_pages):
        the_DCA_page = dict()
        the_DCA_page["profiles"] = list()
        the_DCA_page["names"] = list()
        DCA_pages[this_page] = the_DCA_page
      else:
        the_DCA_page = DCA_pages[this_page]
        if ("profiles" not in the_DCA_page):
          the_DCA_page["profiles"] = list()
        if ("names" not in the_DCA_page):
          the_DCA_page["names"] = list()
      the_DCA_page["profiles"] = the_DCA_page["profiles"] + the_profiles
      the_names = the_DCA_page["names"]
      if (group_name not in the_names):
        the_DCA_page["names"] = the_names + [group_name]
  return

# Assign groups to their preferred DCAs, if possible.
for group_number in group_list:
  group_dict = group_list[group_number]
  if ("preferred_DCA" in group_dict):
    assign_DCA (group_number)

if (do_trace == 1):
  tracefile.write ("DCAs 2:\n")
  pprint.pprint (DCAs, tracefile)  

# Assign groups without preferred DCAs.
for group_number in group_list:
  group_dict = group_list[group_number]
  if ("preferred_DCA" not in group_dict):
    assign_DCA (group_number)

if (do_trace == 1):
  tracefile.write ("DCAs 3:\n")
  pprint.pprint (DCAs, tracefile)  

if (do_trace == 1):
  tracefile.write ("Naming DCAs.\n")

# Give good names to the DCAs
def give_DCA_name (DCA_number, the_page):  
  this_DCA = DCAs[DCA_number]
  if (do_trace == 1):
    tracefile.write ("Naming this_DCA:\n")
    pprint.pprint (this_DCA, tracefile)
  if ("pages" in this_DCA):
    DCA_pages = this_DCA["pages"]
    if the_page in DCA_pages:
      DCA_page = DCA_pages[the_page]
      if (do_trace == 1):
        tracefile.write ("DCA_page:\n")
        pprint.pprint (DCA_page, tracefile)
      if (DCA_style == "solo" and DCA_number == 0):
        DCA_page["name"] = "Solo"
        return
      if ("names" in DCA_page):
        the_names = DCA_page["names"]
        # If there is just one group in this DCA, use its name.
        if (len(the_names) == 1):
          DCA_page["name"] = the_names[0]
          if (do_trace == 1):
            tracefile.write ("DCA " + str(DCA_number) +
                             " named " + DCA_page["name"] +
                             " on page " + the_page + " (1).\n")
          return
        # If there is more than one group, call it "..."
        DCA_page["name"] = "..."
        if (do_trace == 1):
          tracefile.write ("DCA " + str(DCA_number) +
                           "named " + DCA_page["name"] +
                           " on page " + the_page + "(2).\n")
        return
      # No group names for this DCA.  If there is just one profile,
      # use its name.
      if ("profiles" in DCA_page):
        the_profiles = DCA_page["profiles"]
        if (do_trace == 1):
          tracefile.write ("the_profiles:\n")
          pprint.pprint (the_profiles, tracefile)
        if (len(the_profiles) == 1):
          profile_ID = the_profiles[0]
          for the_profile in profile_list:
            if (the_profile["ID"] == profile_ID):
              DCA_page["name"] = the_profile["name"]
              if (do_trace == 1):
                tracefile.write ("DCA " + str(DCA_number) +
                                 " named " + DCA_page["name"] +
                                 " on page " + the_page + " (3).\n")
              return
        # More than one profile: call the DCA "..."
        DCA_page["name"] = "..."
        if (do_trace == 1):
          tracefile.write ("DCA " + str(DCA_number) +
                           " named " + DCA_page["name"] +
                           " on page " + the_page + " (4).\n")
        return
      # No group name and no profiles means a blank name.
      DCA_page["name"] = ""
      if (do_trace == 1):
        tracefile.write ("DCA " + str(DCA_number) +
                         " named " + DCA_page["name"] +
                         " on page " + the_page + " (5).\n")

for the_page in page_list:
  for DCA_number in DCAs:
    give_DCA_name (DCA_number, the_page)
  
if (do_trace == 1):
  tracefile.write ("DCAs 4:\n")
  pprint.pprint (DCAs, tracefile)  

# Tell X32 Theatre Control which profiles to unmute in each page,
# and which DCA they are in.

# DCA_info records information about how the DCAs are used on this page.
# It is a dictionary indexed by DCA number, with entries
# for number, profiles and name.
cue_number = 1;
for this_page in page_list:
  listfile.write ("INSERT INTO cues VALUES (")
  listfile.write (str(cue_number))
  listfile.write (",0, " + '"')
  page_dict = pages[this_page]
  prompt = format_pageno (this_page)
  if ("prompt" in page_dict):
    prompt = page_dict["prompt"]
  listfile.write (prompt)
  listfile.write ('", ')
  DCA_info = dict()
  for DCA_number in DCAs:
    this_DCA = DCAs[DCA_number]
    if (do_trace == 1):
      tracefile.write ("this_DCA for DCA " + str(DCA_number) + ":\n")
      pprint.pprint (this_DCA, tracefile)
    this_DCA_info = dict()
    this_DCA_info["number"] = DCA_number
    DCA_info[DCA_number] = this_DCA_info
    
    DCA_pages = this_DCA["pages"]
    DCA_page_found = 0
    for the_page in DCA_pages:
      if (the_page == this_page):
        DCA_page = DCA_pages[the_page]
        DCA_page_found = 1
    if (DCA_page_found == 1):
      DCA_name = DCA_page["name"]
      if (DCA_name == ""):
        DCA_name = "Solo"
      this_DCA_info["name"] = DCA_name
      this_DCA_info["profiles"] = DCA_page["profiles"]

  if (do_trace == 1):
    tracefile.write ("DCA_info for page " + this_page + ":\n")
    pprint.pprint (DCA_info, tracefile)

  # Write profile IDs for each DCA
  first_DCA = 1
  for DCA_number in range (0,8):
    this_DCA_info = DCA_info[DCA_number]
    if (do_trace == 1):
      tracefile.write ("this_DCA_info for DCA " + str(DCA_number) + ":\n")
      pprint.pprint (this_DCA_info, tracefile)
    if (first_DCA == 0):
      listfile.write (",")
    listfile.write ("'")
    if ("profiles" in this_DCA_info):
      first_profile = 1
      the_profiles = this_DCA_info["profiles"]
      for profile_ID in the_profiles:
        if (first_profile == 0):
          listfile.write (",")
        listfile.write (str(profile_ID))
        if (do_trace == 1):
          tracefile.write ("DCA " + str(DCA_number) +
                           " gets profile " + str(profile_ID) + ".\n")
        first_profile = 0
    listfile.write ("'")
    first_DCA = 0

  # Write the name of each DCA
  first_DCA = 1
  for DCA_number in range (0,8):
    this_DCA_info = DCA_info[DCA_number]
    if ("name" in this_DCA_info):
      listfile.write (", '" + this_DCA_info["name"] + "'")
    else:
      listfile.write (", ''")
  listfile.write (",'', '', '', '', '');\n")
  cue_number = cue_number + 1
  
listfile.write ("CREATE TABLE 'positions' ('id' " +
                "INTEGER PRIMARY KEY AUTOINCREMENT, " +
                "'name' TEXT, 'shortName' TEXT, 'delay' NUMERIC, " +
                "'pan' NUMERIC);\n")
listfile.write ("INSERT INTO positions VALUES(0, 'Centre Stage', " +
                "'CS', 2, 0);\n")
num_positions = 1

listfile.write ("CREATE TABLE 'profiles' ('id' " +
                "INTEGER PRIMARY KEY AUTOINCREMENT, " +
                "'channel' INTEGER, 'name' TEXT, " +
                "'default' INTEGER DEFAULT 0, 'data' TEXT);\n")

if (do_trace == 1):
  tracefile.write ("profile_list 6:\n")
  pprint.pprint (profile_list, tracefile)

for profile in profile_list:
  listfile.write ("INSERT INTO profiles VALUES (")
  listfile.write (str(profile["ID"]) + ", ")
  listfile.write (str(profile["microphone"]) + ", ")
  listfile.write ("'" + profile["name"])
  listfile.write ("', ")
  listfile.write ("1,'');\n")

num_profiles = len(profile_list)

listfile.write ("CREATE TABLE 'ensembles' ('id' " +
                "INTEGER PRIMARY KEY AUTOINCREMENT, " +
                "'name' TEXT, 'channels' TEXT);\n")
listfile.write ("INSERT INTO ensembles VALUES (1, 'All', '")
first_profile=1
for the_profile in profile_list:
  if (first_profile == 0):
    listfile.write (",")
  listfile.write (str(the_profile["ID"]))
  first_profile=0
listfile.write ("');\n")
num_ensembles = 1

# more ensembles
listfile.write ("CREATE TABLE 'snippetCache' (" +
                "'snippet' INTEGER PRIMARY KEY, " +
                "'name' TEXT);\n")
for snippet in range (0, 100):
  listfile.write ("INSERT INTO snippetCache VALUES (" + str(snippet) +
                  ", NULL);\n")
listfile.write ("CREATE TABLE 'fxCache' (" +
                "'fx' INTEGER PRIMARY KEY, 'name' TEXT);\n")

listfile.write ("DELETE FROM sqlite_sequence;\n")
listfile.write ("INSERT INTO sqlite_sequence VALUES('positions', " +
                str(num_positions) + ");\n")
listfile.write ("INSERT INTO sqlite_sequence VALUES('ensembles', " +
                str(num_ensembles) + ");\n")
listfile.write ("INSERT INTO sqlite_sequence VALUES('profiles', " +
                str(num_profiles) + ");\n")
listfile.write ("CREATE UNIQUE INDEX 'cueID' ON 'cues' ('number', 'point');\n")
listfile.write ("COMMIT;\n")
listfile.close()

#
# Output a file showing when each microphone must be switched on
# and off.  When switching a microphone on, indicate its group,
# if one was specified.  If a microphone stays on but changes
# group, indicate this.  Write the informaton in two files.
# The first is intended to be pasted into the script so it can be
# used with a manual sound board, and so is very brief.
# The annotated version is intended for
# programming a sequencer and so includes the profile name.

def find_profile_tex (the_microphone, the_page):
  profile_ID, group_name = find_profile [(the_page, the_microphone)]
  for this_profile in profile_list:
    if (this_profile["ID"] == profile_ID):
      return (quote_for_tex(this_profile["name"]))

# Given a microphone and page, find the corresoonding DCA and its name
def find_DCA (the_microphone, the_page):
  if (do_trace == 1):
    tracefile.write ("Finding a DCA for microphone " + str(the_microphone) +
                     " on page " + the_page + ".\n")
  for DCA_number in DCAs:
    this_DCA = DCAs[DCA_number]
    if ("pages" in this_DCA):
      DCA_pages = this_DCA["pages"]
      if (the_page in DCA_pages):
        DCA_page = DCA_pages[the_page]
        the_profiles = DCA_page["profiles"]
        for profile_ID in the_profiles:
          for the_profile in profile_list:
            if (the_profile["ID"] == profile_ID and
                the_profile ["microphone"] == the_microphone):
              if (do_trace == 1):
                tracefile.write ("Found DCA " + str(this_DCA["number"]) +
                                 " for microphone " + str(the_microphone) +
                                 " on page " + the_page + ".\n")
              return (this_DCA, DCA_page["name"])
  if (do_trace == 1):
    tracefile.write ("No DCA found for microphone " +
                       str(the_microphone) +
                       " on page " + the_page + ".\n")
  return (None, None)
          
max_microphones_in_use_count = 0
microphone_cue_count = 0
max_microphones_in_use_page = ""

listfile1 = open (os.path.join (output_directory, output_root) +
                 ".microphone_switching.tex", "wt")
listfile2 = open (os.path.join (output_directory, output_root) +
                 ".microphone_switching_annotated.tex", "wt")
listfile2.write ("\\begin{description}\n")

prev_microphone_list = []
prev_page = ""
for this_page in page_list:
  this_page_dict = pages[this_page]
  if (do_trace == 1):
    tracefile.write ("Microphone switching instructions for page " +
                     format_pageno(this_page) + ":\n")
    pprint.pprint (this_page_dict, tracefile)
  prompt = ""
  if ("prompt" in this_page_dict):
    prompt = this_page_dict["prompt"]
  if (this_page in microphone_switching_log):
    microphone_list = microphone_switching_log [this_page]
  else:
    microphone_list = []
  microphone_list.sort()
  turn_on_list = []
  turn_off_list = []
  change_group_list = []
  for this_microphone in prev_microphone_list:
    if (this_microphone not in microphone_list):
      turn_off_list.append(this_microphone)
  for this_microphone in microphone_list:
    if (this_microphone not in prev_microphone_list):
      turn_on_list.append(this_microphone)
    else:
      if (microphone_group [(this_page, this_microphone)] !=
          microphone_group [(prev_page, this_microphone)]):
        change_group_list.append(this_microphone)
  if ((len(turn_on_list) > 0) or
      (len(turn_off_list) > 0) or
      (len(change_group_list) > 0)):
    microphone_cue_count = microphone_cue_count + 1
    listfile1.write ("\\vskip 0.25in ")
    if (prompt != ""):
      listfile1.write ("\\vbox {\\parbox[t]{2.5in}{{\\em " +
                       quote_for_tex(prompt) + "} ")
    else:
      listfile1.write ("\\vbox {\\parbox[t]{0.5in}{" +
                       quote_for_tex(format_pageno(this_page)) + "\\hfil}")
      listfile1.write ("\\parbox[t]{2in}{" )
    if (prompt != ""):
      listfile2.write ("\\item[" + quote_for_tex(prompt) + "]\n")
    else:
      listfile2.write ("\\item[" +
                       quote_for_tex(format_pageno(this_page)) + "]\n")
    if (len(turn_on_list) > 0):
      listfile1.write ("On: " )
      listfile2.write ("Switch on ")
      first_microphone = 1
      for this_microphone in turn_on_list:
        if (first_microphone == 0):
          listfile1.write (", ")
          listfile2.write (", ")
        else:
           first_microphone = 0
        listfile1.write (str(this_microphone))
        listfile2.write ("character " +
                         find_profile_tex (this_microphone, this_page) +
                         " on microphone " + str(this_microphone))
        group = microphone_group [(this_page, this_microphone)]
        if (group != ""):
          listfile1.write (" (" + quote_for_tex(group) + ")")
          listfile2.write (" in group " + quote_for_tex(group))
        the_DCA, the_name = find_DCA (this_microphone, this_page)
        if (the_DCA != None):
          listfile2.write (" using DCA " + str(the_DCA["number"]) +
                           " named " + quote_for_tex(the_name))
      listfile1.write (". ")
      listfile2.write (". ")
    if (len(turn_off_list) > 0):
      listfile1.write ("Off: ")
      listfile2.write ("Switch off ")
      first_microphone = 1
      for this_microphone in turn_off_list:
        if (first_microphone == 0):
          listfile1.write (", ")
          listfile2.write (", ")
        else:
           first_microphone = 0
        listfile1.write (str(this_microphone))
        listfile2.write ("character " +
                         find_profile_tex (this_microphone, prev_page) +
                         " on microphone " + str(this_microphone))
      listfile1.write (". ")
      listfile2.write (". ")
    if (len(change_group_list) > 0):
      listfile1.write ("Change group: ")
      first_microphone = 1
      for this_microphone in change_group_list:
        if (first_microphone == 0):
          listfile1.write (", ")
          listfile2.write (". ")
        else:
          first_microphone = 0
        group = microphone_group [(this_page, this_microphone)]
        prev_group = microphone_group [(prev_page, this_microphone)]
        if (group != ""):
          if (prev_group != ""):
            listfile1.write (str(this_microphone) +
                            " moves from " +
                            quote_for_tex(prev_group) +
                            " to " + quote_for_tex(group))
            listfile2.write ("Character " +
                             find_profile_tex(this_microphone, this_page) +
                             " on microphone " +
                             str(this_microphone) +
                             " moves from group " +
                             quote_for_tex(prev_group) +
                             " to group " + quote_for_tex(group))
            the_DCA, the_name = find_DCA (this_microphone, this_page)
            if (the_DCA != None):
              listfile2.write (" using DCA " + str(the_DCA["number"]) +
                               " named " + quote_for_tex(the_name))
          else:
            listfile1.write (str(this_microphone) +
                            " moves to " + quote_for_tex(group))
            listfile2.write ("Character " +
                             find_profile_tex(this_microphone, this_page) +
                             " on microphone " +
                             str(this_microphone) +
                             " moves to group " + quote_for_tex(group))
            the_DCA, the_name = find_DCA (this_microphone, this_page)
            if (the_DCA != None):
              listfile2.write (" using DCA " + str(the_DCA["number"]) +
                               " named " + quote_for_tex(the_name))
        else:
          listfile1.write (str(this_microphone) +
                          " leaves " + quote_for_tex(prev_group))
          listfile2.write ("Character " +
                           find_profile_tex(this_microphone, this_page) +
                           " on microphone " +
                           str(this_microphone) +
                           " leaves group " + quote_for_tex(prev_group))
          the_DCA, the_name = find_DCA (this_microphone, this_page)
          if (the_DCA != None):
            listfile2.write (" now using DCA " + str(the_DCA["number"]) +
                               " named " + quote_for_tex(the_name))

      listfile1.write (". ")
      listfile2.write (". ")

    # If any microphones have been turned off, note which microphones
    # are still on, so the microphone operator can verify that he has
    # not missed an "on" or "off" instruction, or correct the error
    # if he did.
    if (len(turn_off_list) > 0):
      if (len(microphone_list) == 0):
        listfile1.write ("(All off.)")
        listfile2.write ("Note that all microphones are now off.")
      else:
        if (len(microphone_list) == 1):
          listfile1.write ("(Still on: " + str(microphone_list[0]) + ".)")
          listfile2.write ("Note that character " +
                           find_profile_tex (microphone_list[0], this_page) +
                           " on microphone " + str(microphone_list[0]) +
                           " is still on")
          the_DCA, the_name = find_DCA (microphone_list[0], this_page)
          if (the_DCA != None):
            listfile2.write (", using DCA " + str(the_DCA["number"]) +
                             " named " + quote_for_tex(the_name))
          listfile2.write (".")

        else:
          listfile1.write ("(Still on: ")
          listfile2.write ("Note that characters ")
          first_microphone = 1
          for this_microphone in microphone_list:
            if (first_microphone == 0):
              listfile1.write (", ")
              listfile2.write (", ")
            else:
              first_microphone = 0
            listfile1.write (str(this_microphone))
            listfile2.write (find_profile_tex(this_microphone, this_page) +
                             " on microphone " + str(this_microphone))
            the_DCA, the_name = find_DCA (this_microphone, this_page)
            if (the_DCA != None):
              listfile2.write (" using DCA " + str(the_DCA["number"]) +
                               " named " + quote_for_tex(the_name))
          listfile1.write (".)")
          listfile2.write (" are still on.  ")
            
    if (max_microphones_in_use_count < len(microphone_list)):
      max_microphones_in_use_count = len(microphone_list)
      max_microphones_in_use_page = this_page
    listfile1.write ("}}" + "\n")
    listfile2.write ("\n\n")
    prev_microphone_list = microphone_list
    prev_page = this_page

if (len(prev_microphone_list) != 0):
  microphone_cue_count = microphone_cue_count + 1
  listfile1.write ("\\vbox {\parbox[t]{0.3in}{" +
                  format_pageno(page_list[-1]) + "\\hfil}" +
                  "\\parbox[t]{2in}{" + "Off: ")
  listfile2.write ("Switch off ")
  first_microphone = 1
  for this_microphone in prev_microphone_list:
    if (first_microphone == 0):
      listfile1.write (", ")
      listfile2.write (", ")
    else:
      first_microphone = 0
    listfile1.write (str(this_microphone))
    listfile2.write ("character " +
                     find_profile_tex(this_microphone, this_page) +
                     " on microphone " +
                     str(this_microphone))
  listfile1.write (". (All off.)" + "}}" + "\n")
  listfile2.write (". Note that all microphones are off.\n\n")
  
listfile1.close()

listfile2.write ("\\end{description}\n")
listfile2.close()

if ((verbosity_level > 0) and (max_microphones_in_use_page != "")):
  print ("Maximum of " + str(max_microphones_in_use_count) +
         " microphones live on page " + 
         format_pageno(max_microphones_in_use_page) + ".")

if (verbosity_level > 0):
  print ("There are " + str(microphone_cue_count) + " microphone cues.")
    
if (do_trace == 1):
  tracefile.close()

if (error_counter > 0):
  print ("Encountered " + str(error_counter) + " errors.")
